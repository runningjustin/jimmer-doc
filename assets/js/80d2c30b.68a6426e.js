"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[1308],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>k});var n=t(67294);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var p=n.createContext({}),s=function(e){var a=n.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},m=function(e){var a=s(e.components);return n.createElement(p.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,l=e.mdxType,i=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=s(t),k=l,d=u["".concat(p,".").concat(k)]||u[k]||c[k]||i;return t?n.createElement(d,r(r({ref:a},m),{},{components:t})):n.createElement(d,r({ref:a},m))}));function k(e,a){var t=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=u;var o={};for(var p in a)hasOwnProperty.call(a,p)&&(o[p]=a[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var s=2;s<i;s++)r[s]=t[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},85162:(e,a,t)=>{t.d(a,{Z:()=>r});var n=t(67294),l=t(34334);const i="tabItem_Ymn6";function r(e){let{children:a,hidden:t,className:r}=e;return n.createElement("div",{role:"tabpanel",className:(0,l.Z)(i,r),hidden:t},a)}},65488:(e,a,t)=>{t.d(a,{Z:()=>k});var n=t(83117),l=t(67294),i=t(34334),r=t(72389),o=t(67392),p=t(7094),s=t(12466);const m="tabList__CuJ",c="tabItem_LNqP";function u(e){var a;const{lazy:t,block:r,defaultValue:u,values:k,groupId:d,className:g}=e,b=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),N=k??b.map((e=>{let{props:{value:a,label:t,attributes:n}}=e;return{value:a,label:t,attributes:n}})),h=(0,o.l)(N,((e,a)=>e.value===a.value));if(h.length>0)throw new Error(`Docusaurus error: Duplicate values "${h.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===u?u:u??(null==(a=b.find((e=>e.props.default)))?void 0:a.props.value)??b[0].props.value;if(null!==v&&!N.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${N.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:T,setTabGroupChoices:y}=(0,p.U)(),[x,f]=(0,l.useState)(v),I=[],{blockElementScrollPositionUntilNextRender:w}=(0,s.o5)();if(null!=d){const e=T[d];null!=e&&e!==x&&N.some((a=>a.value===e))&&f(e)}const B=e=>{const a=e.currentTarget,t=I.indexOf(a),n=N[t].value;n!==x&&(w(a),f(n),null!=d&&y(d,String(n)))},Z=e=>{var a;let t=null;switch(e.key){case"ArrowRight":{const a=I.indexOf(e.currentTarget)+1;t=I[a]??I[0];break}case"ArrowLeft":{const a=I.indexOf(e.currentTarget)-1;t=I[a]??I[I.length-1];break}}null==(a=t)||a.focus()};return l.createElement("div",{className:(0,i.Z)("tabs-container",m)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":r},g)},N.map((e=>{let{value:a,label:t,attributes:r}=e;return l.createElement("li",(0,n.Z)({role:"tab",tabIndex:x===a?0:-1,"aria-selected":x===a,key:a,ref:e=>I.push(e),onKeyDown:Z,onFocus:B,onClick:B},r,{className:(0,i.Z)("tabs__item",c,null==r?void 0:r.className,{"tabs__item--active":x===a})}),t??a)}))),t?(0,l.cloneElement)(b.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},b.map(((e,a)=>(0,l.cloneElement)(e,{key:a,hidden:e.props.value!==x})))))}function k(e){const a=(0,r.Z)();return l.createElement(u,(0,n.Z)({key:String(a)},e))}},68038:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>m,contentTitle:()=>p,default:()=>k,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=t(83117),l=(t(67294),t(3905)),i=t(65488),r=t(85162);const o={sidebar_position:9,title:"DSL Expressions"},p=void 0,s={unversionedId:"query/expression",id:"query/expression",title:"DSL Expressions",description:"Literal Expressions",source:"@site/docs/query/expression.mdx",sourceDirName:"query",slug:"/query/expression",permalink:"/jimmer-doc/docs/query/expression",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/tree/main/docs/query/expression.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"DSL Expressions"},sidebar:"tutorialSidebar",previous:{title:"Deep Pagination Optimization",permalink:"/jimmer-doc/docs/query/paging/deep-optimization"},next:{title:"Native SQL Expressions",permalink:"/jimmer-doc/docs/query/native-sql"}},m={},c=[{value:"Literal Expressions",id:"literal-expressions",level:2},{value:"Constant Expressions",id:"constant-expressions",level:2},{value:"Static Predicates vs Dynamic Predicates",id:"static-predicates-vs-dynamic-predicates",level:2},{value:"Comparison",id:"comparison",level:2},{value:"Fuzzy Matching",id:"fuzzy-matching",level:2},{value:"Case Sensitivity",id:"case-sensitivity",level:3},{value:"Match Modes",id:"match-modes",level:3},{value:"Null Check",id:"null-check",level:2},{value:"IN LIST",id:"in-list",level:2},{value:"Single Column",id:"single-column",level:3},{value:"Multiple Columns",id:"multiple-columns",level:3},{value:"AND, OR, NOT",id:"and-or-not",level:2},{value:"AND",id:"and",level:3},{value:"OR",id:"or",level:3},{value:"NOT",id:"not",level:3},{value:"Math Operations",id:"math-operations",level:2},{value:"Aggregate Functions",id:"aggregate-functions",level:2},{value:"Coalesce",id:"coalesce",level:2},{value:"Concat",id:"concat",level:2},{value:"Case",id:"case",level:2},{value:"Simple Case",id:"simple-case",level:3},{value:"Searched Case",id:"searched-case",level:3}],u={toc:c};function k(e){let{components:a,...t}=e;return(0,l.kt)("wrapper",(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"literal-expressions"},"Literal Expressions"),(0,l.kt)("p",null,"Let's first look at an example ",(0,l.kt)("em",{parentName:"p"},"(this query has no real business logic, just for demo)"),":"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<\n    Tuple5<\n        String,\n        Long,\n        OffsetDateTime,\n        String,\n        Boolean\n    >\n> tuples = sqlClient\n    .createQuery(book)\n    .select(\n        Expression.string().value("String"),\n        Expression.numeric().value(3L),\n        Expression.comparable().value(OffsetDateTime.now()),\n        Expression.any().value("String"),\n        Expression.nullValue(Boolean.class)\n    )\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples = sqlClient\n    .createQuery(Book::class) {\n        select(\n            value("String"),\n            value(3L),\n            value(OffsetDateTime.now()),\n            value("String"),\n            nullValue(Boolean::class)\n        )\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select ?, ?, ?, ?, null from BOOK as tb_1_ \n")),(0,l.kt)("p",null,"Except for null, literals of other types all become JDBC parameters.  "),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"As can be seen from this example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"value()")," method accepts many parameter types."),(0,l.kt)("p",{parentName:"admonition"},"Note that no matter what the ",(0,l.kt)("inlineCode",{parentName:"p"},"value()")," parameter type is, it cannot be null, otherwise exceptions would be thrown."),(0,l.kt)("p",{parentName:"admonition"},"To create literal expressions for null, the ",(0,l.kt)("inlineCode",{parentName:"p"},"nullValue()")," method must be used which requires the expression type to be specified. ")),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"For Java code, type-guided methods are used:"),(0,l.kt)("ol",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ol"},"Expression.string(), for string type."),(0,l.kt)("li",{parentName:"ol"},"Expression.numeric(), for numeric types. "),(0,l.kt)("li",{parentName:"ol"},"Expression.comparable(), for comparable types, i.e. types extending java.lang.Comparable."),(0,l.kt)("li",{parentName:"ol"},"Expression.any(), for other types.")),(0,l.kt)("p",{parentName:"admonition"},"Kotlin does not have this issue, its API is unified.")),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"In most cases, developers do not need to manually create literal expressions. "),(0,l.kt)("p",{parentName:"admonition"},"Take equality check in examples below for instance, the relatively tedious syntax:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().eq(\n        Expression.string().value("Java in Action")\n    )\n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table.name eq value("Java in Action")\n)\n')))),(0,l.kt)("p",{parentName:"admonition"},"Isn't this a bit tedious? Don't worry, it can be replaced with a more convenient form:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().eq("Java in Action"));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name eq "Java in Action")\n')))),(0,l.kt)("p",{parentName:"admonition"},"It's easy to see other APIs provide overloaded versions to avoid making developers create literal expressions manually."),(0,l.kt)("p",{parentName:"admonition"},"But this can't cover 100% cases. In very rare cases, developers still need to create literal expressions manually.")),(0,l.kt)("h2",{id:"constant-expressions"},"Constant Expressions"),(0,l.kt)("p",null,"Constant expressions are highly similar to literal expressions, let's look at an example ",(0,l.kt)("em",{parentName:"p"},"(this query has no real business logic, just for demo)"),":"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Integer> constants = sqlClient\n    .createQuery(book)\n    .select(\n        // highlight-next-line\n        Expression.constant(1)\n    )\n    .execute(); \n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val constants = sqlClient\n    .createQuery(Book::class) {\n        select(\n            // highlight-next-line\n            constant(1)\n        )\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    1\nfrom BOOK as tb_1_\n")),(0,l.kt)("p",null,"Unlike literal expressions that always use JDBC parameters, constant expressions directly hardcode the value into the SQL."),(0,l.kt)("p",null,"To prevent SQL injection attacks, constant expressions only support numeric types, this is a hard constraint."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Although constant expressions have this hard constraint of only supporting numeric types to prevent SQL injection, they should still be strictly limited in real projects.  "),(0,l.kt)("p",{parentName:"admonition"},"The only reason constant expressions exist is that some databases support function-based indexes. Constant expressions can be useful if the SQL expressions defining such function indexes contain numeric constants."),(0,l.kt)("p",{parentName:"admonition"},"If your project does not have this scenario, never use constant expressions. Always use literal expressions."),(0,l.kt)("p",{parentName:"admonition"},"Incorrect use of constant expressions can have serious consequences. Erroneously planting unstable numeric variables as constant expressions into SQL will break the stability of the SQL string, eventually leading to extremely low hit rates of execution plan cache in the database, impacting performance.")),(0,l.kt)("h2",{id:"static-predicates-vs-dynamic-predicates"},"Static Predicates vs Dynamic Predicates"),(0,l.kt)("p",null,"Initially, Jimmer supported dynamic queries through ",(0,l.kt)("inlineCode",{parentName:"p"},"whereIf"),":"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public List<Book> findBooks(\n    @Nullable String name,\n    @Nullable Integer edition\n) {\n    BookTable table = BookTable.$;\n    return sqlClient\n        .createQuery(table)\n        .whereIf(\n            name != null && !name.isEmpty(),\n            () -> table().name().ilike(name)\n        )\n        .whereIf(\n            edition != null,\n            table().edition().eq(edition)\n        )\n        .select(table)\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findBooks(\n    name: String? = null,\n    edition: Int? = null\n): List<Book> =\n    sqlClient\n        .createQuery(Book::class) {\n            name?.takeIf { it.isNotEmpty() }?.let {\n                where(table.name ilike it)\n            }\n            edition?.let {\n                where(table.edition eq it)\n            }\n            select(table)\n        }\n        .execute()\n")))),(0,l.kt)("p",null,"Although ",(0,l.kt)("inlineCode",{parentName:"p"},"whereIf")," has good readability, the code is relatively cumbersome. Later, Jimmer provided dynamic predicates, which simplified the above code to:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public List<Book> findBooks(\n    @Nullable String name,\n    @Nullable Integer edition\n) {\n    BookTable table = BookTable.$;\n    return sqlClient\n        .createQuery(table)\n        .where(table.name().ilikeIf(name))\n        .where(table.edition().eqIf(edition))\n        .select(table)\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findBooks(\n    name: String? = null,\n    edition: Int? = null\n): List<Book> =\n    sqlClient\n        .createQuery(Book::class) {\n            where(table.name `ilike?` name)\n            where(table.name `eq?` edition)\n            select(table)\n        }\n        .execute()\n")))),(0,l.kt)("p",null,"Here, ",(0,l.kt)("inlineCode",{parentName:"p"},"ilikeIf"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"eqIf")," in Java and ",(0,l.kt)("inlineCode",{parentName:"p"},"ilike?"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"eq?")," in Kotlin are called dynamic predicates."),(0,l.kt)("p",null,"When the right operand is null or an empty string (string of length 0), the dynamic predicate does not create an expression and directly returns null. The ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," call can automatically ignore null, thereby achieving an equivalent dynamic query."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Compared to the initial ",(0,l.kt)("inlineCode",{parentName:"p"},"whereIf"),", the value of dynamic predicates is not in simplifying the code but in accommodating more complex scenarios, such as ",(0,l.kt)("inlineCode",{parentName:"p"},"or"),":")),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public List<Book> findBooksByNameOrPriceRange(\n    @Nullable String name,\n    @Nullable BigDecimal minPrice,\n    @Nullable BigDecimal maxPrice\n) {\n    BookTable table = BookTable.$;\n    return sqlClient\n        .createQuery(table)\n        .where(\n            // highlight-next-line\n            Predicate.or(\n                table.name().eqIf(name),\n                table.price().betweenIf(minPrice, maxPrice)\n            )\n        )\n        .select(table)\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findBooksByNameOrPriceRange(\n    name: String? = null,\n    minPrice: BigDecimal? = null,\n    maxPrice: BigDecimal? = null\n): List<Book> =\n    sqlClient\n        .createQuery(Book::class) {\n            where(\n                // highlight-next-line\n                or(\n                    table.name `eq?` name,\n                    table.price.`between?`(minPrice, maxPrice)\n                )\n            )\n            select(table)\n        }\n        .execute()\n")))),(0,l.kt)("p",null,"Here, all the arguments of ",(0,l.kt)("inlineCode",{parentName:"p"},"or")," are dynamic predicates, meaning each argument of ",(0,l.kt)("inlineCode",{parentName:"p"},"or")," can be null, and ",(0,l.kt)("inlineCode",{parentName:"p"},"or")," can also ignore null arguments. Of course, if all arguments are null, then ",(0,l.kt)("inlineCode",{parentName:"p"},"or")," itself will refuse to create any expression and directly return null."),(0,l.kt)("p",null,"Here are all the static predicates and dynamic predicates in Jimmer:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Static Predicate"),(0,l.kt)("th",{parentName:"tr",align:null},"Dynamic Predicate (Java)"),(0,l.kt)("th",{parentName:"tr",align:null},"Dynamic Predicate (Kotlin)"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"eq"),(0,l.kt)("td",{parentName:"tr",align:null},"eqIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","eq?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ne"),(0,l.kt)("td",{parentName:"tr",align:null},"neIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","ne?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lt"),(0,l.kt)("td",{parentName:"tr",align:null},"ltIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","lt?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"le"),(0,l.kt)("td",{parentName:"tr",align:null},"leIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","le?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"gt"),(0,l.kt)("td",{parentName:"tr",align:null},"gtIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","gt?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ge"),(0,l.kt)("td",{parentName:"tr",align:null},"geIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","ge?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"like"),(0,l.kt)("td",{parentName:"tr",align:null},"likeIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","like?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ilike"),(0,l.kt)("td",{parentName:"tr",align:null},"ilikeIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","ilike?","`")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"between"),(0,l.kt)("td",{parentName:"tr",align:null},"betweenIf"),(0,l.kt)("td",{parentName:"tr",align:null},"`","between","`")))),(0,l.kt)("p",null,"Q: Why does Jimmer provide two sets of predicates instead of just providing dynamic predicates?"),(0,l.kt)("p",null,"A: Because static predicates also handle null specially:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"eq: automatically converted to isNull()"),(0,l.kt)("li",{parentName:"ul"},"ne: automatically converted to isNotNull()"),(0,l.kt)("li",{parentName:"ul"},"Other static predicates:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Java: Treats this as a bug in the user's code, requiring the user to either provide a non-null value or switch to a dynamic predicate."),(0,l.kt)("li",{parentName:"ul"},"Kotlin: Prevents the user from providing potentially null values at compile-time.")))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"We have clearly discussed the concept of dynamic predicates. To simplify subsequent discussions, the rest of this content will only demonstrate static predicates.")),(0,l.kt)("h2",{id:"comparison"},"Comparison"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Equals"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().eq("SQL in Action"));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name eq "SQL in Action")\n'))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Not equals"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().ne("SQL in Action"));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name ne "SQL in Action")\n'))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Greater than  "),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().gt(new BigDecimal(50)));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price gt BigDecimal(50))\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Greater than or equals"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().ge(new BigDecimal(50)));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price ge BigDecimal(50))\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Less than"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().lt(new BigDecimal(50)));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price lt BigDecimal(50))\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Less than or equals"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().le(new BigDecimal(50)));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price le BigDecimal(50))\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Between"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    book.price().between(\n        new BigDecimal(40),\n        new BigDecimal(50)\n    )\n);\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(\n    table.price.between(\n        BigDecimal(40),\n        BigDecimal(50)\n    )\n)\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Not Between"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    book.price().notBetween(\n        new BigDecimal(40),\n        new BigDecimal(50)  \n    )\n);\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(\n    table.price.notBetween(\n        BigDecimal(40),\n        BigDecimal(50)\n    )\n)\n")))))),(0,l.kt)("h2",{id:"fuzzy-matching"},"Fuzzy Matching"),(0,l.kt)("h3",{id:"case-sensitivity"},"Case Sensitivity"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"like"),": case sensitive"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab"));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name like "Ab")\n')))),(0,l.kt)("p",{parentName:"li"},"The generated SQL condition is:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_.NAME like ?\n")),(0,l.kt)("p",{parentName:"li"},"The corresponding JDBC parameter is: ",(0,l.kt)("inlineCode",{parentName:"p"},"%Ab%"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"ilike"),": case insensitive"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().ilike("Ab"));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name ilike "Ab") \n')))),(0,l.kt)("p",{parentName:"li"},"The generated SQL condition is:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If ",(0,l.kt)("inlineCode",{parentName:"p"},"ilike")," is supported by dialect"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_.NAME ilike ? \n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Otherwise"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"where lower(tb_1_.NAME) like ? \n")))),(0,l.kt)("p",{parentName:"li"},"The corresponding JDBC parameter is: ",(0,l.kt)("inlineCode",{parentName:"p"},"%ab%")," "))),(0,l.kt)("h3",{id:"match-modes"},"Match Modes"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"LikeMode.ANYWHERE")," (default behavior without specifying): appears anywhere"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.ANYWHERE)); \n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.ANYWHERE))\n')))),(0,l.kt)("p",{parentName:"li"},"The corresponding JDBC parameter is: ",(0,l.kt)("inlineCode",{parentName:"p"},"%Ab%"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"LikeMode.START"),": as prefix "),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.START));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.START)) \n')))),(0,l.kt)("p",{parentName:"li"},"The corresponding JDBC parameter is: ",(0,l.kt)("inlineCode",{parentName:"p"},"Ab%"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"LikeMode.END"),": as suffix"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.END));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.END))\n')))),(0,l.kt)("p",{parentName:"li"},"The corresponding JDBC parameter is: ",(0,l.kt)("inlineCode",{parentName:"p"},"%Ab"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"LikeMode.EXACT"),": exact match"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.EXACT));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.EXACT)) \n')))),(0,l.kt)("p",{parentName:"li"},"The corresponding JDBC parameter is: ",(0,l.kt)("inlineCode",{parentName:"p"},"Ab")))),(0,l.kt)("h2",{id:"null-check"},"Null Check"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(book.store().isNull());\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.store.isNull())\n")))),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(book.store().isNotNull());\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.store.isNotNull())\n")))),(0,l.kt)("h2",{id:"in-list"},"IN LIST"),(0,l.kt)("h3",{id:"single-column"},"Single Column"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().in(\n        Arrays.asList(\n            "SQL in Action",  \n            "Java in Action"\n        )\n    )\n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table.name valueIn listOf(\n        "SQL in Action",\n        "Java in Action" \n    )\n)\n')))),(0,l.kt)("p",null,"The generated SQL condition is: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_.NAME in (?, ?)  \n")),(0,l.kt)("h3",{id:"multiple-columns"},"Multiple Columns"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    Expression.tuple(\n        book.name(),\n        book.edition()  \n    ).in(\n        Arrays.asList(\n            new Tuple2<>("SQL in Action", 1),\n            new Tuple2<>("SQL in Action", 2),\n            new Tuple2<>("Java in Action", 1), \n            new Tuple2<>("Java in Action", 2)\n        )\n    )\n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    tuple(\n        table.name,\n        table.edition\n    ) valueIn listOf(\n        Tuple2("SQL in Action", 1),\n        Tuple2("SQL in Action", 2),\n        Tuple2("Java in Action", 1),\n        Tuple2("Java in Action", 2)\n    )\n)\n')))),(0,l.kt)("p",null,"The generated SQL condition is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"where (tb_1_.NAME, tb_1_.EDITION) in (\n    (?, ?), (?, ?), (?, ?), (?, ?) \n)\n")),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"Besides used with collections, ",(0,l.kt)("inlineCode",{parentName:"p"},"in")," can also be used with subqueries.  "),(0,l.kt)("p",{parentName:"admonition"},"This will be covered in detail in docs about ",(0,l.kt)("a",{parentName:"p",href:"../query/sub-query"},"subqueries"),".")),(0,l.kt)("h2",{id:"and-or-not"},"AND, OR, NOT"),(0,l.kt)("h3",{id:"and"},"AND"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    Predicate.and(\n        book.name().like("Ab"),\n        book.price().ge(new BigDecimal(40)), \n        book.price().lt(new BigDecimal(60))\n    )\n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    and(\n        table.name like "Ab",\n        table.price ge BigDecimal(40),\n        table.price lt BigDecimal(60)\n    )\n) \n')))),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"Note that when the logical AND expression is directly used as the where parameter, the following equivalent forms are more recommended:  ")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Use varargs version of where method"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().like("Ab"),\n    book.price().ge(new BigDecimal(40)),\n    book.price().lt(new BigDecimal(60))\n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table.name like "Ab",\n    table.price ge BigDecimal(40), \n    table.price lt BigDecimal(60)\n)\n'))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Call where multiple times"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'q.where(book.name().like("Ab"));\nq.where(book.price().ge(new BigDecimal(40)));\nq.where(book.price().lt(new BigDecimal(60)));\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name like "Ab")\nwhere(table.price ge BigDecimal(40)) \nwhere(table.price lt BigDecimal(60))\n')))))),(0,l.kt)("p",null,"So directly using ",(0,l.kt)("inlineCode",{parentName:"p"},"and")," would not be common in real projects."),(0,l.kt)("h3",{id:"or"},"OR"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    // highlight-next-line\n    Predicate.or(\n        book.name().like("Ab"),\n        book.price().ge(new BigDecimal(40)),\n        book.price().le(new BigDecimal(60))\n    )\n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    // highlight-next-line\n    or(\n        table.name like "Ab",\n        table.price ge BigDecimal(40),\n        table.price le BigDecimal(60)\n    )\n)\n')))),(0,l.kt)("h3",{id:"not"},"NOT"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().like("Ab").not()  \n);\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    not(table.name like "Ab")\n);\n')))),(0,l.kt)("p",null,"It's not always necessary to call the ",(0,l.kt)("inlineCode",{parentName:"p"},"not()")," function. Often there are shortcuts available, such as:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},".eq(value).not()")," can be simplified to ",(0,l.kt)("inlineCode",{parentName:"li"},".ne(value)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},".isNull().not()")," can be simplified to ",(0,l.kt)("inlineCode",{parentName:"li"},".isNotNull(value)"),"  "),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},".exists().not()")," can be simplified to ",(0,l.kt)("inlineCode",{parentName:"li"},".notExists()")," ",(0,l.kt)("em",{parentName:"li"},"(exists will be introduced in ",(0,l.kt)("a",{parentName:"em",href:"../query/sub-query"},"subqueries"),")"))),(0,l.kt)("p",null,"Even when developers explicitly use ",(0,l.kt)("inlineCode",{parentName:"p"},"not()"),", the final SQL may not contain ",(0,l.kt)("inlineCode",{parentName:"p"},"NOT"),". For example:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    book.price().ge(new BigDecimal(40)).not()\n);\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(\n    not(book.price ge BigDecimal(40)) \n)\n")))),(0,l.kt)("p",null,"The actual generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_1.PRICE < ?\n")),(0,l.kt)("p",null,"Jimmer-sql tries to avoid directly using ",(0,l.kt)("inlineCode",{parentName:"p"},"NOT")," in SQL, but the final logic is equivalent to what you want."),(0,l.kt)("h2",{id:"math-operations"},"Math Operations"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"+"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().plus(BigDecimal.TWO));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price + BigDecimal.TWO)\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"-"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().minus(BigDecimal.TWO));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price - BigDecimal.TWO)\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"*"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().times(BigDecimal.TWO)); \n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price * BigDecimal.TWO)\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"/"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().div(BigDecimal.TWO));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price / BigDecimal.TWO)\n"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"%"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().rem(BigDecimal.TWO));\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price % BigDecimal.TWO)\n")))))),(0,l.kt)("h2",{id:"aggregate-functions"},"Aggregate Functions"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<\n    Tuple6<\n        Long,\n        Long,\n        BigDecimal,\n        BigDecimal,\n        BigDecimal,\n        BigDecimal  \n    >\n> tuples = sqlClient\n    .createQuery(book)\n    .select(\n        book.count(),\n        book.id().count(/* disintct */ true),\n        book.price().sum(),\n        book.price().min(),\n        book.price().max(),\n        book.price().avg()\n    )\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val tuples = sqlClient\n    .createQuery(Book::class) {\n        select(\n            count(table),\n            count(table.id, distinct = true),\n            sum(table.price),\n            min(table.price),\n            max(table.price),\n            avg(table.price)\n        );\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"The final generated SQL is:  "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    count(tb_1_.ID),\n    count(distinct tb_1_.ID),\n    sum(tb_1_.PRICE),\n    min(tb_1_.PRICE),\n    max(tb_1_.PRICE),\n    avg(tb_1_.PRICE)\nfrom BOOK as tb_1_ \n")),(0,l.kt)("h2",{id:"coalesce"},"Coalesce"),(0,l.kt)("p",null,"The Coalesce statement specifies a list of expressions and returns the first non-null value."),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookStoreTable store = Tables.BOOK_STORE_TABLE;\n\nList<String> results = sqlClient\n    .createQuery(store) \n    .select(\n        store.website() \u2776\n            // highlight-next-line\n            .coalesceBuilder()\n            .or(store.name()) \u2777\n            .or("Default Value") \u2778\n            .build()\n    )\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"var results = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.website\n                // highlight-next-line\n                .coalesce() \u2776\n                .or(table.name) \u2777\n                .end()\n        )\n    }\n")))),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"In this example, the Kotlin code is different from the Java code. In Kotlin there is no expression \u2778.  "),(0,l.kt)("p",{parentName:"admonition"},"The Kotlin API introduces null-safety for SQL, ",(0,l.kt)("inlineCode",{parentName:"p"},"table.name")," is a non-null field, so Kotlin forces us to write ",(0,l.kt)("inlineCode",{parentName:"p"},"end()")," to complete the expression.  "),(0,l.kt)("p",{parentName:"admonition"},"This means the expression \u2778 in Java code will not be used.")),(0,l.kt)("p",null,"The generated SQL is: "),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"SQL for Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    coalesce(\n        tb_1_.WEBSITE,\n        tb_1_.NAME,\n        ?  \n    )\nfrom BOOK_STORE as tb_1_ \n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"SQL for Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    coalesce(\n        tb_1_.WEBSITE,\n        tb_1_.NAME \n    )\nfrom BOOK_STORE as tb_1_\n")))),(0,l.kt)("p",null,"Specifically, if the SQL coalesce function has only two parameters, i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"or()")," is called only once in the Java code above, there is a shortcut:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookStoreTable store = Tables.BOOK_STORE_TABLE;\n\nList<String> results = sqlClient\n    .createQuery(store)\n    .select(\n        // highlight-next-line\n        store.website().coalesce(store.name()) \n    )\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"var results = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            // highlight-next-line\n            table.website.coalesce(table.name)\n        )\n    }\n")))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    coalesce(tb_1_.WEBSITE, tb_1_.NAME)\nfrom BOOK_STORE as tb_1_ \n")),(0,l.kt)("p",null,"This form is actually the most common."),(0,l.kt)("h2",{id:"concat"},"Concat"),(0,l.kt)("p",null,"The Contact expression concatenates strings. "),(0,l.kt)("p",null,"This example concatenates ",(0,l.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"lastName")," of authors with a space as separator:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTable author = Tables.AUTHOR_TABLE;  \n\nList<String> results = sqlClient\n    .createQuery(author)\n    .select(\n        author\n            .firstName()\n            // highlight-next-line\n            .concat(\n                Expression.string().value(" "), \n                author.lastName()\n            )\n    )\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'var fullNames = sqlClient\n    .createQuery(Author::class) {\n        select(\n            // highlight-next-line\n            concat(\n                table.firstName,\n                value(" "),\n                table.lastName\n            )\n        )\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    concat(\n        tb_1_.FIRST_NAME,\n        ?,\n        tb_1_.LAST_NAME  \n    )\nfrom AUTHOR as tb_1_\n")),(0,l.kt)("h2",{id:"case"},"Case"),(0,l.kt)("p",null,"There are two types of case expressions, simple case and searched case."),(0,l.kt)("h3",{id:"simple-case"},"Simple Case"),(0,l.kt)("p",null,"For simple case, an expression is specified at the beginning. Each WHEN branch specifies an expected value to check if the expression matches that value."),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<String> results = sqlClient\n    .createQuery(book)\n    .select(\n        Expression.string()\n            // highlight-next-line\n            .caseBuilder(book.name())\n            .when("Java in Action", "Matched")\n            .when("SQL in Action", "Matched")\n            .otherwise("Not matched")\n    )\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val results = sqlClient\n    .createQuery(Book::class) {\n        select(\n            // highlight-next-line\n            case(table.name)\n                .match("Kotlin in Action", "Matched")\n                .match("SQL in Action", "Matched")\n                .otherwise("Not matched")\n        )\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    case tb_1_.NAME\n        when ? then ?\n        when ? then ?\n        else ?\n    end\nfrom BOOK as tb_1_ \n")),(0,l.kt)("h3",{id:"searched-case"},"Searched Case"),(0,l.kt)("p",null,"For searched case, no expression is specified at the beginning. Each WHEN branch can specify an arbitrary complex conditional expression to check if any branch logic evaluates to true."),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<String> results = sqlClient\n    .createQuery(book)\n    .select(\n        Expression.string()\n            // highlight-next-line \n            .caseBuilder()\n            .when(\n                book.price().lt(new BigDecimal(30)), \n                "Cheap"\n            )\n            .when(\n                book.price().gt(new BigDecimal(70)),\n                "Expensive"  \n            )\n            .otherwise("Appropriate")\n    )\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val results = sqlClient\n    .createQuery(Book::class) {\n        select(\n            // highlight-next-line\n            case()\n                .match(table.price lt BigDecimal(30), "Cheap")\n                .match(table.price gt BigDecimal(70), "Expensive")\n                .otherwise("Appropriate")\n        )\n    }\n    .execute() \n')))),(0,l.kt)("p",null,"The generated SQL is: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* highlight-next-line */\n    case\n        when tb_1_.PRICE < ? then ?\n        when tb_1_.PRICE > ? then ?\n        else ?\n    end\nfrom BOOK as tb_1_\n")))}k.isMDXComponent=!0}}]);