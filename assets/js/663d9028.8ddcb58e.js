"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[9073],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>d});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=i.createContext({}),s=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=s(e.components);return i.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,p=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=s(t),d=a,k=c["".concat(p,".").concat(d)]||c[d]||u[d]||l;return t?i.createElement(k,o(o({ref:n},m),{},{components:t})):i.createElement(k,o({ref:n},m))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,o=new Array(l);o[0]=c;var r={};for(var p in n)hasOwnProperty.call(n,p)&&(r[p]=n[p]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var s=2;s<l;s++)o[s]=t[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},32239:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>s});var i=t(83117),a=(t(67294),t(3905));const l={sidebar_position:7,title:"Join Features Specific to Kotlin"},o=void 0,r={unversionedId:"query/dynamic-join/kotlin-join",id:"query/dynamic-join/kotlin-join",title:"Join Features Specific to Kotlin",description:"Dilemma",source:"@site/docs/query/dynamic-join/kotlin-join.mdx",sourceDirName:"query/dynamic-join",slug:"/query/dynamic-join/kotlin-join",permalink:"/jimmer-doc/docs/query/dynamic-join/kotlin-join",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/tree/main/docs/query/dynamic-join/kotlin-join.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Join Features Specific to Kotlin"},sidebar:"tutorialSidebar",previous:{title:"Weak Join",permalink:"/jimmer-doc/docs/query/dynamic-join/weak-join"},next:{title:"\ud83d\udd25 Implicit Subquery",permalink:"/jimmer-doc/docs/query/implicit-subquery"}},p={},s=[{value:"Dilemma",id:"dilemma",level:2},{value:"Getting Started with DSL&#39;s Null Safety",id:"getting-started-with-dsls-null-safety",level:2},{value:"Null Safety in Table Joins",id:"null-safety-in-table-joins",level:2},{value:"Inner Join",id:"inner-join",level:3},{value:"Left Join",id:"left-join",level:3}],m={toc:s};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"dilemma"},"Dilemma"),(0,a.kt)("p",null,"In order to take full advantage of Kotlin's language features and optimize its development experience, Jimmer provides different APIs for Java and Kotlin, but they are essentially the same. "),(0,a.kt)("p",null,"However, outer joins are the only exception. For this detail, the behaviors of Java API and Kotlin API are different:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Java DSL\nUse ",(0,a.kt)("inlineCode",{parentName:"p"},"JoinType")," to represent join type, which can be ",(0,a.kt)("inlineCode",{parentName:"p"},"INNER")," ",(0,a.kt)("em",{parentName:"p"},"(default)"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"LEFT"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"RIGHT")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"FULL"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Kotlin DSL"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Properties with the same name as entity properties represent inner joins")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Properties with a ",(0,a.kt)("inlineCode",{parentName:"p"},"?")," after the entity properties name represent left joins"))),(0,a.kt)("p",{parentName:"li"},"That is, Kotlin DSL does not support ",(0,a.kt)("inlineCode",{parentName:"p"},"RIGHT")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"FULL"),". This sacrifice is a careful trade-off, in exchange for a more important feature for Kotlin: perfectly combining Kotlin's null safety and SQL DSL."))),(0,a.kt)("h2",{id:"getting-started-with-dsls-null-safety"},"Getting Started with DSL's Null Safety"),(0,a.kt)("p",null,"The entity ",(0,a.kt)("inlineCode",{parentName:"p"},"BookStore")," is defined as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Entity\ninterface BookStore {\n\n    val name: String\n\n    val website: String?\n\n    // Omit other code\n}\n")),(0,a.kt)("p",null,"The precompiled code generates: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'public val KNonNullProps<BookStore>.name: KNonNullPropExpression<String>\n    get() = get("name")\n\npublic val KNullableProps<BookStore>.name: KNullablePropExpression<String>\n    get() = get("name")\n\npublic val KProps<BookStore>.website: KNullablePropExpression<String>\n    get() = get("website")\n')),(0,a.kt)("p",null,"Please ignore the details of the generated code for now. We can see many types containing ",(0,a.kt)("inlineCode",{parentName:"p"},"NonNull")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Nullable"),"."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"In Jimmer's Kotlin SQL DSL, almost all AST types have both ",(0,a.kt)("inlineCode",{parentName:"p"},"NonNull")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Nullable")," implementations."),(0,a.kt)("p",{parentName:"admonition"},"This means Kotlin SQL DSL has null safety features equivalent to Kotlin language itself. SQL-style query code has complete null safety self-checking capabilities.  ")),(0,a.kt)("p",null,"Let's look at a simple example first:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.name,\n            table.website \u2776\n        )\n    }\n    .execute()\nfor ((name, website) in books) { \u2777\n    println("Length of name: ${name.length}")\n    // Compile error  \n    // highlight-next-line\n    println("Length of website: ${website.length}") \u2778\n}\n')),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Since ",(0,a.kt)("inlineCode",{parentName:"li"},"BookStore.website")," is nullable, the type of the second column selected at \u2776 is ",(0,a.kt)("inlineCode",{parentName:"li"},"String?")," instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"String"),".\nThe final return type of the query is ",(0,a.kt)("inlineCode",{parentName:"li"},"List<Tuple2<String, String?>>"),"."),(0,a.kt)("li",{parentName:"ol"},"\u2777 Loops through each tuple queried, destructuring into variables ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"website"),".\nSince ",(0,a.kt)("inlineCode",{parentName:"li"},"tuples")," is of type ",(0,a.kt)("inlineCode",{parentName:"li"},"List<Tuple2<String, String?>>"),", here ",(0,a.kt)("inlineCode",{parentName:"li"},"website")," is of type ",(0,a.kt)("inlineCode",{parentName:"li"},"String?"),"."),(0,a.kt)("li",{parentName:"ol"},"\u2778 Performs ",(0,a.kt)("inlineCode",{parentName:"li"},".length")," operation on potentially null ",(0,a.kt)("inlineCode",{parentName:"li"},"website"),", causing compile error.")),(0,a.kt)("p",null,"To fix this compile error, modify code at \u2778 to change ",(0,a.kt)("inlineCode",{parentName:"p"},".")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"?."),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'println("Length of website: ${website?.length}")\n')),(0,a.kt)("h2",{id:"null-safety-in-table-joins"},"Null Safety in Table Joins"),(0,a.kt)("p",null,"In the above, we learned the simplest null safety in SQL DSL through a very simple example."),(0,a.kt)("p",null,"Now, let's combine null safety with table join operations:"),(0,a.kt)("h3",{id:"inner-join"},"Inner Join"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.name, \n            table.store.name \u2776\n        )\n    }\n    .execute()\nfor ((name, storeName) in books) { \u2777\n    println("Length of name: ${name.length}")\n    println("Length of storeName: ${storeName.length}") \u2778\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2776 Uses inner join to get parent object's name. The final return type of the query is ",(0,a.kt)("inlineCode",{parentName:"p"},"List<Tuple2<String, String>>"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2777 Destructures into variables ",(0,a.kt)("inlineCode",{parentName:"p"},"storeName")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),", non-nullable. So code at \u2778 compiles. "))),(0,a.kt)("h3",{id:"left-join"},"Left Join"),(0,a.kt)("p",null,"Let's modify the code to change inner join to outer join:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.name,\n            table.`store?`.name \u2776\n        ) \n    }\n    .execute()\nfor ((name, storeName) in books) { \u2777\n    println("Length of name: ${name.length}")\n    // Compile error\n    // highlight-next-line  \n    println("Length of storeName: ${storeName.length}") \u2778\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2776 Uses left join to get parent object."),(0,a.kt)("p",{parentName:"li"},"The precompiled code in ",(0,a.kt)("inlineCode",{parentName:"p"},"BookProps.kt")," includes:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'public val KProps<Book>.store: KNonNullTable<BookStore>\n    get() = join("store")\n\npublic val KProps<Book>.`store?`: KNullableTable<BookStore>  \n    get() = outerJoin("store")\n')),(0,a.kt)("p",{parentName:"li"},"Unlike inner join ",(0,a.kt)("inlineCode",{parentName:"p"},"store"),", outer join ",(0,a.kt)("inlineCode",{parentName:"p"},"store?")," returns a table of type ",(0,a.kt)("inlineCode",{parentName:"p"},"KNullableTable"),", i.e. nullable table. This is the effect of left join in SQL."),(0,a.kt)("p",{parentName:"li"},"The precompiled code in ",(0,a.kt)("inlineCode",{parentName:"p"},"BookStoreProps.kt")," includes:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'public val KNonNullProps<BookStore>.name: KNonNullPropExpression<String>\n    get() = get("name") \u2779\n\npublic val KNullableProps<BookStore>.name: KNullablePropExpression<String>\n    get() = get("name") \u277a\n')),(0,a.kt)("p",{parentName:"li"},"The returned ",(0,a.kt)("inlineCode",{parentName:"p"},"KNullableTable")," inherits from ",(0,a.kt)("inlineCode",{parentName:"p"},"KNullableProps")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"KNonNullProps"),"."),(0,a.kt)("p",{parentName:"li"},"So in the DSL, accessing ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," matches \u277a instead of \u2779."),(0,a.kt)("p",{parentName:"li"},"That is, just ",(0,a.kt)("inlineCode",{parentName:"p"},"BookStore.name")," being non-null is not enough, need to also consider if the table it is accessed from is non-null."),(0,a.kt)("p",{parentName:"li"},"Ultimately, Jimmer determines the second column in \u2776 is ",(0,a.kt)("inlineCode",{parentName:"p"},"String?"),", so the return type is ",(0,a.kt)("inlineCode",{parentName:"p"},"List<Tuple2<String, String?>>"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u2777 Destructures into ",(0,a.kt)("inlineCode",{parentName:"p"},"storeName")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"String?"),", nullable. This must cause compile error at \u2778."))),(0,a.kt)("p",null,"To fix this compile error, modify code at \u2778 to change ",(0,a.kt)("inlineCode",{parentName:"p"},".")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"?."),": "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'println("Length of storeName: ${storeName?.length}") \u2778  \n')))}u.isMDXComponent=!0}}]);