"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[7981],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(n),g=i,u=c["".concat(s,".").concat(g)]||c[g]||d[g]||r;return n?a.createElement(u,o(o({ref:t},m),{},{components:n})):a.createElement(u,o({ref:t},m))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),i=n(34334);const r="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,o),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>g});var a=n(83117),i=n(67294),r=n(34334),o=n(72389),l=n(67392),s=n(7094),p=n(12466);const m="tabList__CuJ",d="tabItem_LNqP";function c(e){var t;const{lazy:n,block:o,defaultValue:c,values:g,groupId:u,className:h}=e,k=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=g??k.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),N=(0,l.l)(b,((e,t)=>e.value===t.value));if(N.length>0)throw new Error(`Docusaurus error: Duplicate values "${N.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const f=null===c?c:c??(null==(t=k.find((e=>e.props.default)))?void 0:t.props.value)??k[0].props.value;if(null!==f&&!b.some((e=>e.value===f)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${f}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:v}=(0,s.U)(),[T,C]=(0,i.useState)(f),w=[],{blockElementScrollPositionUntilNextRender:x}=(0,p.o5)();if(null!=u){const e=y[u];null!=e&&e!==T&&b.some((t=>t.value===e))&&C(e)}const j=e=>{const t=e.currentTarget,n=w.indexOf(t),a=b[n].value;a!==T&&(x(t),C(a),null!=u&&v(u,String(a)))},S=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=w.indexOf(e.currentTarget)+1;n=w[t]??w[0];break}case"ArrowLeft":{const t=w.indexOf(e.currentTarget)-1;n=w[t]??w[w.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",m)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":o},h)},b.map((e=>{let{value:t,label:n,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>w.push(e),onKeyDown:S,onFocus:j,onClick:j},o,{className:(0,r.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":T===t})}),n??t)}))),n?(0,i.cloneElement)(k.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function g(e){const t=(0,o.Z)();return i.createElement(c,(0,a.Z)({key:String(t)},e))}},77373:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>g,frontMatter:()=>l,metadata:()=>p,toc:()=>d});var a=n(83117),i=(n(67294),n(3905)),r=n(65488),o=n(85162);const l={sidebar_position:7,title:"\ud83d\udd25 Trigger"},s=void 0,p={unversionedId:"mutation/trigger",id:"mutation/trigger",title:"\ud83d\udd25 Trigger",description:"Jimmer supports triggers that allow users to listen for database changes.",source:"@site/docs/mutation/trigger.mdx",sourceDirName:"mutation",slug:"/mutation/trigger",permalink:"/jimmer-doc/docs/mutation/trigger",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/tree/main/docs/mutation/trigger.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"\ud83d\udd25 Trigger"},sidebar:"tutorialSidebar",previous:{title:"Interceptor before save",permalink:"/jimmer-doc/docs/mutation/draft-interceptor"},next:{title:"\ud83d\udd25 Cache",permalink:"/jimmer-doc/docs/cache/"}},m={},d=[{value:"Trigger Types",id:"trigger-types",level:2},{value:"Trigger Classification",id:"trigger-classification",level:3},{value:"Recommended Usage",id:"recommended-usage",level:3},{value:"Setting Trigger Type",id:"setting-trigger-type",level:2},{value:"Concept",id:"concept",level:3},{value:"Q &amp; A",id:"q--a",level:3},{value:"Using Jimmer Spring Boot Starter",id:"using-jimmer-spring-boot-starter",level:3},{value:"Not Using Jimmer Spring Boot Starter",id:"not-using-jimmer-spring-boot-starter",level:3},{value:"BinLog Trigger Development Work",id:"binlog-trigger-development-work",level:2},{value:"Create External Environment",id:"create-external-environment",level:3},{value:"Listen to Message Queue",id:"listen-to-message-queue",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Register Handler Logic",id:"register-handler-logic",level:3},{value:"Experience Triggers",id:"experience-triggers",level:3}],c={toc:d};function g(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Jimmer supports triggers that allow users to listen for database changes."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Triggers can notify changes not only to objects, but also to associations.")),(0,i.kt)("h2",{id:"trigger-types"},"Trigger Types"),(0,i.kt)("h3",{id:"trigger-classification"},"Trigger Classification"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"BinLog Trigger"),(0,i.kt)("p",{parentName:"li"},"This is the default trigger type. It does not affect the SQL generated by Jimmer itself, has higher performance, is triggered after transaction commit, can listen to database changes caused by any reason, including data changes not caused by Jimmer API."),(0,i.kt)("p",{parentName:"li"},"However, it requires the database to support binlog/CDC.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Transaction Trigger"),(0,i.kt)("p",{parentName:"li"},"This trigger does not requires the database to support binlog/CDC, it is triggered before transaction commit. "),(0,i.kt)("p",{parentName:"li"},"However, It can only listener to the data changes caused by current Jimmer application, and will generate additional query statements during the modification process to simulate the trigger, which has some impact on modification performance."),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Its working mechanism is similar to ",(0,i.kt)("a",{parentName:"p",href:"https://seata.io/en-us/docs/dev/mode/at-mode.html"},"Alibaba Seata's AT mode"))))),(0,i.kt)("p",null,"The differences between the two triggers are as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},"BinLog Trigger"),(0,i.kt)("th",{parentName:"tr",align:null},"Transaction Trigger"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Trigger Time"),(0,i.kt)("td",{parentName:"tr",align:null},"After transaction commit"),(0,i.kt)("td",{parentName:"tr",align:null},"Before transaction commit")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Performance"),(0,i.kt)("td",{parentName:"tr",align:null},"High"),(0,i.kt)("td",{parentName:"tr",align:null},"Low")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Database changes listened"),(0,i.kt)("td",{parentName:"tr",align:null},"Changes caused by any reason"),(0,i.kt)("td",{parentName:"tr",align:null},"Only changes caused by calling current application's Jimmer API")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Database Requirements"),(0,i.kt)("td",{parentName:"tr",align:null},"Support and enable binlog/CDC"),(0,i.kt)("td",{parentName:"tr",align:null},"No requirements")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Working Principle"),(0,i.kt)("td",{parentName:"tr",align:null},"Use third-party technology to push database binlog changes to message queue, Jimmer application listens to message queue"),(0,i.kt)("td",{parentName:"tr",align:null},"Any Jimmer modification API automatically implants additional SQL queries to find data changes, similar to ",(0,i.kt)("a",{parentName:"td",href:"https://seata.io/en-us/docs/dev/mode/at-mode.html"},"Alibaba Seata's AT mode"))))),(0,i.kt)("p",null,"Apart from the differences in this table, the notification data provided by the two triggers to the user is exactly the same."),(0,i.kt)("h3",{id:"recommended-usage"},"Recommended Usage"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"BinLog Trigger"),(0,i.kt)("p",{parentName:"li"},"The BinLog trigger is triggered after transaction commit, facing the immutable facts."),(0,i.kt)("p",{parentName:"li"},"That is, the BinLog trigger has no impact on the original transaction, and is allowed to perform time-consuming operations. So it is suitable to execute multiple tasks in its handling logic, especially these tasks:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Cache invalidation"),(0,i.kt)("li",{parentName:"ul"},"Heterogeneous data source synchronization"),(0,i.kt)("li",{parentName:"ul"},"Send messages to other microservices asynchronously"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Transaction Trigger"),(0,i.kt)("p",{parentName:"li"},"The Transaction trigger is triggered before transaction commit, and its handling logic is injected directly into the current transaction."),(0,i.kt)("p",{parentName:"li"},"If an exception occurs in its event handling logic, it will cause the current transaction to fail; if its handling logic cannot complete quickly, it will cause the current transaction to hold resources for a long time."),(0,i.kt)("p",{parentName:"li"},"Therefore, the Transaction trigger is suitable for appending more modification behaviors in the current transaction without compromising atomicity."),(0,i.kt)("p",{parentName:"li"},"It is suitable for implementing business logic with strong generality through additional modifications when the database changes."))),(0,i.kt)("h2",{id:"setting-trigger-type"},"Setting Trigger Type"),(0,i.kt)("h3",{id:"concept"},"Concept"),(0,i.kt)("p",null,"Before discussing setting the trigger type, let's see how developers use triggers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(false)"),":\nReturns BinLog trigger first, if not exists, returns Transaction trigger.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(true)"),":\nExplicitly returns Transaction trigger, throws exception if not exists."))),(0,i.kt)("p",null,"To affect the trigger type that can be obtained by ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers()")," afterwards, you need to specify TriggerType when building SqlClient."),(0,i.kt)("p",null,"TriggerType has three possible values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"BINLOG_ONLY:"),(0,i.kt)("p",{parentName:"li"},"  Only supports BinLog trigger, this is the default configuration."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sqlClient.getTriggers()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sqlClient.getTriggers(false)")," return BinLog trigger object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sqlClient.getTriggers(true)")," will throw an exception, cannot return Transaction trigger object"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"TRANSACTION_ONLY:"),(0,i.kt)("p",{parentName:"li"},"  Only supports Transaction trigger.\nNo matter what the parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers")," is, it will return the same Transaction trigger object.\n")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"BOTH:"),(0,i.kt)("p",{parentName:"li"},"  Supports both BinLog trigger and Transaction trigger."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sqlClient.getTriggers()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sqlClient.getTriggers(false)")," return BinLog trigger object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sqlClient.getTriggers(true)")," returns Transaction trigger object")))),(0,i.kt)("p",null,"Here is a table to compare the three cases:"),(0,i.kt)("table",null,(0,i.kt)("thead",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Trigger Type"),(0,i.kt)("th",null,"getTriggers(false)"),(0,i.kt)("th",null,"getTriggers(true)"))),(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"BINLOG_ONLY"),(0,i.kt)("td",null,"Dedicated binlog triggers object"),(0,i.kt)("td",null,(0,i.kt)("span",{style:{color:"red"}},"Throw exception"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"TRANSACTION_ONLY"),(0,i.kt)("td",{colspan:"2"},(0,i.kt)("center",null,(0,i.kt)("b",null,"Shared")," transaction triggers object"))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"BOTH"),(0,i.kt)("td",null,"Dedicated binlog triggers object"),(0,i.kt)("td",null,"Dedicated transaction triggers object")))),(0,i.kt)("h3",{id:"q--a"},"Q & A"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Q"),": Why is ",(0,i.kt)("inlineCode",{parentName:"p"},"BINLOG_ONLY")," the default mode?"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"A"),": Transaction triggers implant additional queries in all save operations to simulate triggers, which impacts performance, so it is disabled by default.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Q"),": In ",(0,i.kt)("inlineCode",{parentName:"p"},"TRANSACTION_ONLY")," mode, why do the two different trigger APIs share the same object?"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"A"),": Jimmer's built-in cache consistency strategy must be driven by ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(false)"),", which developers cannot change."),(0,i.kt)("p",{parentName:"li"},"The purpose is to allow cache consistency maintenance work to not affect the modification transaction, and only start execution after transaction commit. Thus, the original transaction will not be elongated and can end quickly to release lock resources."),(0,i.kt)("p",{parentName:"li"},"However, not all database products support binlog/CDC. In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"getTriggers(false)")," returns the transaction trigger object, masquerading as the BinLog trigger object, taking over cache consistency maintenance work that should have been handled by the BinLog trigger."),(0,i.kt)("p",{parentName:"li"},"That is to say, ",(0,i.kt)("inlineCode",{parentName:"p"},"TRANSACTION_ONLY")," is designed for databases that do not support binlog/CDC, ",(0,i.kt)("strong",{parentName:"p"},"this is the only reason to use this mode"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Q"),": In ",(0,i.kt)("inlineCode",{parentName:"p"},"BOTH")," mode, there are two different trigger API objects, does this mean there are two chances to handle any modification?"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"A"),": Yes, and this is an important feature."),(0,i.kt)("p",{parentName:"li"},"Unlike Jimmer's built-in cache consistency mechanism which must be driven by ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(false)"),", the user's business code does not have this limitation. Developers can freely decide whether an event handling logic should be registered to ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(false)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(true)"),", or registered to both at the same time."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the developer's event handling logic contains some additional modifications that must participate in the atomic scope of the current transaction, ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(true)")," should be chosen.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the developer's event handling logic does not need to participate in the current transaction, ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers(false)")," should be chosen to allow the current transaction to end as soon as possible and release lock resources as soon as possible.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the developer's event handling logic contains both of the above cases, it should be split into two and registered to the two triggers respectively."),(0,i.kt)("admonition",{parentName:"li",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"If the developer registers the same event callback for two types of triggers, then this callback will indeed be executed twice each time an event is notified."),(0,i.kt)("p",{parentName:"admonition"},"At this point, distinguishing between the two calls is very important. The parameter of the callback method is an object that can obtain the JDBC connection object. Whether its value is null can be used as a criterion to distinguish between the two:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Non-null: First callback, caused by transaction trigger  "),(0,i.kt)("li",{parentName:"ul"},"Null: Second callback, caused by binlog trigger")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Q"),": For databases that do not support binlog/CDC, isn't it impossible to do cache cleanup after transaction commit?"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"A"),": Not exactly, it can be achieved if the developer is willing to optimize."),(0,i.kt)("p",{parentName:"li"},"Admittedly, such databases cannot support binlog triggers, and using transaction triggers to get data change notifications within the transaction lifetime is the only feasible method."),(0,i.kt)("p",{parentName:"li"},"However, it is not necessary to perform cache cleanup immediately after receiving the notification, because the cache cleanup work on remote caches like redis has network communication costs and risks of communication failure. Doing so will elongate or even fail the local transaction."),(0,i.kt)("p",{parentName:"li"},"Jimmer's cache system supports custom CacheOperator. By customizing CacheOperator, users can override the cache deletion behavior, record the cache deletion tasks but not execute them immediately, and perform the actual cache cleanup after the transaction is committed."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Unreliable approach"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Customize CacheOperator and do not immediately clear the cache, but use ThreadLocal to record the keys of the caches to be deleted."),(0,i.kt)("li",{parentName:"ol"},"Collectively clean up the cache in Spring's ",(0,i.kt)("inlineCode",{parentName:"li"},"AfterCommit")," event."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Reliable approach"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Customize CacheOperator and do not immediately clear the cache, but use a local event table in the same database to record the keys of the caches to be deleted.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"In Spring's ",(0,i.kt)("inlineCode",{parentName:"p"},"AfterCommit")," event, take data from the local event table, clean up the cache, and if successful, delete the data in the local event table.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use a polling service to cover failures in step 2."),(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Fortunately, for trigger type ",(0,i.kt)("inlineCode",{parentName:"p"},"TRANSACTION_ONLY"),", Jimmer's Spring Boot Starter has already implemented this. Please refer to ",(0,i.kt)("a",{parentName:"p",href:"../cache/consistency"},"Cache Consistency/Transaction Trigger"))))))))),(0,i.kt)("h3",{id:"using-jimmer-spring-boot-starter"},"Using Jimmer Spring Boot Starter"),(0,i.kt)("p",null,"If using the Jimmer Spring Boot Starter, setting the trigger type is very simple."),(0,i.kt)("p",null,"Just add a configuration in ",(0,i.kt)("inlineCode",{parentName:"p"},"application.properties")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"application.yml"),". Its name is ",(0,i.kt)("inlineCode",{parentName:"p"},"jimmer.trigger-type"),", and its value is ",(0,i.kt)("inlineCode",{parentName:"p"},"BINLOG_ONLY")," | ",(0,i.kt)("inlineCode",{parentName:"p"},"TRANSACTION_ONLY")," | ",(0,i.kt)("inlineCode",{parentName:"p"},"BOTH"),"."),(0,i.kt)("h3",{id:"not-using-jimmer-spring-boot-starter"},"Not Using Jimmer Spring Boot Starter"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    // highlight-next-line \n    .setTriggerType(TriggerType.BOTH)\n    ...other config omitted...\n    .build();\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"javax.sql.DataSource dataSource = ...;\n\nval sqlClient = newKSqlClient {\n    // highlight-next-line\n    setTriggerType(TriggerType.BOTH)\n    ...other config omitted...\n}\n")))),(0,i.kt)("h2",{id:"binlog-trigger-development-work"},"BinLog Trigger Development Work"),(0,i.kt)("p",null,"Unlike Transaction triggers, BinLog triggers require third-party technologies to push database binlog changes to the message queue, and applications need to listen to the message queue."),(0,i.kt)("p",null,"Therefore, just specifying TriggerType as ",(0,i.kt)("inlineCode",{parentName:"p"},"BINLOG_ONLY")," ",(0,i.kt)("em",{parentName:"p"},"(default behavior)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"BOTH")," when building the SqlClient object is not enough."),(0,i.kt)("p",null,"There are many choices for the message queue, such as Kafka and RabbitMQ; there are also many choices for third-party technologies to push database binlog incrementally to the message queue, such as MaxWell, Debezium, Canal and DataBus."),(0,i.kt)("p",null,"Jimmer does not restrict such choices. But to simplify the discussion, this article assumes Kafka is used as the message queue, and Maxwell ",(0,i.kt)("em",{parentName:"p"},"(For MySQL)")," and Debezium ",(0,i.kt)("em",{parentName:"p"},"(For postgres)")," are used as the push technologies."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Because Debezium itself is a kafka-connector, using Debezium inevitably leads to Kafka being the message queue.")),(0,i.kt)("h3",{id:"create-external-environment"},"Create External Environment"),(0,i.kt)("p",null,"Before development, the environment needs to be installed first, including the database, Kafka, and Maxwell or Debezium."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Maxwell"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Enter the local directory corresponding to ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/babyfish-ct/jimmer/blob/main/example/env-with-cache/maxwell"},"example/env-with-cache/maxwell")," after ",(0,i.kt)("inlineCode",{parentName:"li"},"git clone"),"."),(0,i.kt)("li",{parentName:"ol"},"Execute",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"bash ./install.sh\n"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Debezium"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Enter the local directory corresponding to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/example/env-with-cache/debezium"},"example/env-with-cache/debezium")," after ",(0,i.kt)("inlineCode",{parentName:"p"},"git clone"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Execute"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"bash ./install.sh\n")))))),(0,i.kt)("h3",{id:"listen-to-message-queue"},"Listen to Message Queue"),(0,i.kt)("p",null,"Whether choosing different databases ",(0,i.kt)("em",{parentName:"p"},"(MySQL or Postgres)"),", or choosing different push technologies ",(0,i.kt)("em",{parentName:"p"},"(Maxwell or Debezium)"),", there will be differences in the listening code."),(0,i.kt)("p",null,"But in any case, the user code is quite similar, divided into the following 4 steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Listen to the message queue and get the message body string.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("a",{parentName:"p",href:"https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html#readTree(java.lang.String)"},"ObjectMapper.readTree")," for weakly typed parsing of the message text."),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"So-called weakly typed parsing means the resulting type is ",(0,i.kt)("a",{parentName:"p",href:"https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/JsonNode.html"},"JsonNode"),", unrelated to business system types. "))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Observe the content of the ",(0,i.kt)("a",{parentName:"p",href:"https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/JsonNode.html"},"JsonNode")," and extract:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Table name, referred to as ",(0,i.kt)("inlineCode",{parentName:"p"},"tableName"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The sub-",(0,i.kt)("a",{parentName:"p",href:"https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/JsonNode.html"},"JsonNode")," of the old data before modification, referred to as ",(0,i.kt)("inlineCode",{parentName:"p"},"oldJsonNode")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"For insert operations, ",(0,i.kt)("inlineCode",{parentName:"p"},"oldJsonNode")," is null"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The sub-",(0,i.kt)("a",{parentName:"p",href:"https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/JsonNode.html"},"JsonNode")," of the new data after modification, referred to as ",(0,i.kt)("inlineCode",{parentName:"p"},"newJsonNode")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"For delete operations, ",(0,i.kt)("inlineCode",{parentName:"p"},"newJsonNode")," is null")))),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The differences in listening code caused by different choices of database and push technology are reflected in this step. However, it is not difficult after observing the message content for inserts, updates, and deletes."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Call ",(0,i.kt)("inlineCode",{parentName:"p"},"JSqlClient.getBinLog().accept")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"KSqlCient.binLog.accept")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"tableName"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"oldJsonNode")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"newJsonNode"),"."))),(0,i.kt)("p",null,"The following examples demonstrate ",(0,i.kt)("inlineCode",{parentName:"p"},"MySQL + Maxwell")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Postgres + Debezium")," respectively."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"MySQL + Maxwell"),(0,i.kt)("p",{parentName:"li"},"For ",(0,i.kt)("inlineCode",{parentName:"p"},"MySQL + Maxwell"),", the message format is typically like:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "database":"jimmer_demo",\n    "table":"book",\n    "type":"update",\n    "ts":1688592724, \n    "xid":11790,\n    "commit":true,\n    "data":{\n        "id":1,\n        "name":"Learning GraphQL",\n        "edition":1,\n        "price":50,\n        "store_id":1,\n        "tenant":"a",\n        "created_time":"2023-07-05 20:21:00",\n        "modified_time":"2023-07-05 20:21:00"\n    },\n    "old":{\n        "store_id":2\n    }\n}\n')),(0,i.kt)("p",{parentName:"li"},"After a little observation ",(0,i.kt)("em",{parentName:"p"},"(it is recommended to look at the messages for insert, update, and delete)"),", it is not difficult to implement the following message listening code:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="MaxwellListener.java"',title:'"MaxwellListener.java"'},'@Component\npublic class MaxwellListener {\n\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n\n    private final Caches caches;\n\n    public MaxwellListener(JSqlClient sqlClient) {\n        this.caches = sqlClient.getCaches();\n    }\n\n    @KafkaListener(topics = "maxwell")\n    public void onMaxwellEvent(\n            String json,\n            Acknowledgment acknowledgment\n    ) throws JsonProcessingException {\n        JsonNode node = MAPPER.readTree(json);\n        String tableName = node.get("table").asText();\n        String type = node.get("type").asText();\n        JsonNode data = node.get("data");\n        switch (type) {\n            case "insert":\n                binLog.accept(tableName, null, data);\n                break;\n            case "update":\n                binLog.accept(tableName, node.get("old"), data);\n                break;\n            case "delete":\n                binLog.accept(tableName, data, null);\n                break;\n        }\n        acknowledgment.acknowledge();\n    }\n}\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="MaxwellListener.kt"',title:'"MaxwellListener.kt"'},'@Component\nclass MaxwellListener(sqlClient: KSqlClient) {\n\n    private val caches: KCaches = sqlClient.caches\n\n    @KafkaListener(topics = ["maxwell"])\n    fun onMaxwellEvent(\n        json: String,\n        acknowledgment: Acknowledgment\n    ) {\n        val node = MAPPER.readTree(json)\n        val tableName = node["table"].asText()\n        val type = node["type"].asText()\n        val data = node["data"]\n        when (type) {\n            "insert" ->\n                binLog.accept(tableName, null, data)\n            "update" ->\n                binLog.accept(tableName, node["old"], data) \n            "delete" ->\n                binLog.accept(tableName, data, null)\n        }\n        acknowledgment.acknowledge()\n    }\n\n    companion object {\n        private val MAPPER = ObjectMapper()\n    }\n}\n'))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Postgres + Debezium"),(0,i.kt)("p",{parentName:"li"},"For ",(0,i.kt)("inlineCode",{parentName:"p"},"Postgres + Debezium"),", the message format is typically:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "before": {\n        "id": 10,\n        "name": "GraphQL in Action",\n        "edition": 1,\n        "price": "H0A=", \n        "store_id": 1,\n        "tenant": "b",\n        "created_time": 1688590805971294,\n        "modified_time": 1688590805971294\n    },\n    "after": {\n        ...omitted...\n    },\n    "source": {\n        "table": "book",\n        ...omitted... \n    },\n    ...omitted...\n}\n')),(0,i.kt)("p",{parentName:"li"},"We find some difficulties here, not all data can be directly recognized and converted by Jimmer's BinLog mapping mechanism:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Properties of ",(0,i.kt)("inlineCode",{parentName:"p"},"BigDecimal")," type ",(0,i.kt)("em",{parentName:"p"},"(",(0,i.kt)("inlineCode",{parentName:"em"},"NUMERIC(M[, D])")," in Postgres)")," like ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price")," are displayed as Base64 encoded ",(0,i.kt)("em",{parentName:"p"},"(",(0,i.kt)("inlineCode",{parentName:"em"},"H0A=")," in this example)"),"."),(0,i.kt)("p",{parentName:"li"},"This Base64 string is the info processed by ",(0,i.kt)("a",{parentName:"p",href:"https://kafka.apache.org/0100/javadoc/org/apache/kafka/connect/data/Decimal.html"},"org.apache.kafka.connect.data.Decimal"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Properties of ",(0,i.kt)("inlineCode",{parentName:"p"},"LocalDateTime")," type ",(0,i.kt)("em",{parentName:"p"},"(TIMESTAMP in Postgres)")," are displayed as numbers"))),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Debezium's documentation will explain in detail how its various connectors process certain special data, such as ",(0,i.kt)("a",{parentName:"p",href:"https://debezium.io/documentation/reference/stable/connectors/postgresql.html#postgresql-decimal-types"},"how pg-connector handles decimal"),"."),(0,i.kt)("p",{parentName:"admonition"},"The various connectors in Debezium also provide rich configurations, some of which can be used to change the default data handling method, such as ",(0,i.kt)("a",{parentName:"p",href:"https://debezium.io/documentation/reference/stable/connectors/postgresql.html#postgresql-property-decimal-handling-mode"},"changing how decimal data is handled"),", to avoid similar problems."),(0,i.kt)("p",{parentName:"admonition"},'However, Debezium\'s connectors usually serve all systems, and will not deliberately "pamper" a particular application. We cannot assume its configuration will always ensure output that Jimmer can understand directly.'),(0,i.kt)("p",{parentName:"admonition"},"The examples that come with Jimmer deliberately do not configure the Debezium connector, letting it output kafka-connector specific data to demonstrate how Jimmer solves this problem, same as this article.")),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="DebeziumCustomizer.java"',title:'"DebeziumCustomizer.java"'},"package ...omitted...;\n\nimport org.apache.kafka.connect.data.Decimal;\nimport org.apache.kafka.connect.data.Schema;\nimport org.babyfish.jimmer.sql.runtime.Customizer;\n\n...other imports omitted...\n\n@Component\npublic class DebeziumCustomizer implements Customizer {\n\n    private static final Schema BOOK_PRICE_SCHEMA =\n            // Postgres `BOOK.PRICE` is `NUMERIC(10, 2)`, precision is 2\n            Decimal.schema(2);\n\n    @Override\n    public void customize(JSqlClient.Builder builder) {\n        \n        builder.setBinLogPropReader( \u2776\n                LocalDateTime.class,\n                (prop, jsonNode) -> {\n                    return Instant.ofEpochMilli(\n                            jsonNode.asLong() / 1000\n                    ).atZone(ZoneId.systemDefault()).toLocalDateTime();\n                }\n        );\n\n        builder.setBinLogPropReader(\n                BookProps.PRICE, \u2777\n                (prop, jsonNode) -> {\n                    byte[] bytes = Base64.getDecoder().decode(jsonNode.asText());\n                    return Decimal.toLogical(BOOK_PRICE_SCHEMA, bytes);\n                }\n        );\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="DebeziumCustomizer.kt"',title:'"DebeziumCustomizer.kt"'},"package ...omitted...\n\nimport org.apache.kafka.connect.data.Decimal\nimport org.apache.kafka.connect.data.Schema\nimport org.babyfish.jimmer.sql.kt.cfg.KCustomizer\n\n...other imports omitted...\n\n@Component\nclass DebeziumCustomizer : KCustomizer {\n\n    override fun customize(dsl: KSqlClientDsl) {\n\n        dsl.setBinLogPropReader(\n            LocalDateTime::class \u2776\n        ) { _, jsonNode ->\n            Instant.ofEpochMilli(\n                jsonNode.asLong() / 1000\n            ).atZone(ZoneId.systemDefault()).toLocalDateTime()\n        }\n\n        dsl.setBinLogPropReader(\n            Book::price \u2777\n        ) { _, jsonNode ->\n            Decimal.toLogical(\n                BOOK_PRICE_SCHEMA,\n                Base64.getDecoder().decode(jsonNode.asText())\n            )\n        }\n    }\n\n    companion object {\n        private val BOOK_PRICE_SCHEMA =\n            // Postgres `BOOK.PRICE` is `NUMERIC(10, 2)`, precision is 2\n            Decimal.schema(2)\n    }\n}\n")))),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"setBinLogPropReader")," allows developers to customize how to parse properties in the message that cannot be directly recognized, with two usages:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 Given the return type, specify how a type of properties should be parsed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 Precisely define how a certain property should be parsed"))),(0,i.kt)("p",{parentName:"li"},"After solving these problems, the message listening code is easy to implement:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="DebeziumListener.java"',title:'"DebeziumListener.java"'},'@Component\npublic class DebeziumListener {\n\n    private static final ObjectMapper MAPPER = new ObjectMapper();\n\n    private final BinLog binLog;\n\n    public DebeziumListener(JSqlClient sqlClient) {\n        this.binLog = sqlClient.getBinLog();\n    }\n\n    @KafkaListener(topicPattern = "debezium\\\\..*") \n    public void onDebeziumEvent(\n            @Payload(required = false) String json,\n            Acknowledgment acknowledgment\n    ) throws JsonProcessingException {\n        if (json != null) { // Debezium sends empty msg after delete msg\n            JsonNode node = MAPPER.readTree(json);\n            String tableName = node.get("source").get("table").asText();\n            binLog.accept(\n                    tableName,\n                    node.get("before"),\n                    node.get("after")\n            );\n        }\n        acknowledgment.acknowledge();\n    }\n}\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="DebeziumListener.kt"',title:'"DebeziumListener.kt"'},'@Component\nclass DebeziumListener(sqlClient: KSqlClient) {\n\n    private val binLog: BinLog = sqlClient.binLog\n\n    @KafkaListener(topicPattern = """debezium\\..*""")\n    fun onDebeziumEvent(\n        @Payload(required = false) json: String?,\n        acknowledgment: Acknowledgment\n    ) {\n        if (json !== null) { \n            val node: JsonNode = MAPPER.readTree(json)\n            val tableName: String = node["source"]["table"].asText()\n            binLog.accept(\n                tableName,\n                node["before"],\n                node["after"]\n            )\n        }\n        acknowledgment.acknowledge()\n    }\n\n    companion object {\n        private val MAPPER = ObjectMapper()\n    }\n}\n')))))),(0,i.kt)("h2",{id:"usage-examples"},"Usage Examples"),(0,i.kt)("p",null,"If using BinLog trigger, please enable it first as described above."),(0,i.kt)("h3",{id:"register-handler-logic"},"Register Handler Logic"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Using Jimmer Spring Boot Starter"),(0,i.kt)("p",{parentName:"li"},"If using the Jimmer Spring Boot Starter, trigger events will be sent as Spring events."),(0,i.kt)("p",{parentName:"li"},"So use ",(0,i.kt)("inlineCode",{parentName:"p"},"@org.springframework.context.event.EventListener")," to handle Spring events:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="DatabaseListener.java"',title:'"DatabaseListener.java"'},'@Component\npublic class DatabaseListener {\n\n    // highlight-next-line\n    @EventListener\n    public void onEntityChanged(EntityEvent<?> e) {\n        if (e.getImmutableType().getJavaClass() == Book.class) {\n            System.out.println("The object `Book` is changed");\n            System.out.println("\\told: " + e.getOldEntity());\n            System.out.println("\\tnew: " + e.getNewEntity());\n        }\n    }\n\n    // highlight-next-line\n    @EventListener\n    public void onAssociationChanged(AssociationEvent e) {\n        if (e.isChanged(BookProps.STORE)) {\n            System.out.println("The many-to-one association `Book.store` is changed");\n            System.out.println("\\tbook id: " + e.getSourceId());\n            System.out.println("\\tdetached book store id: " + e.getDetachedTargetId());\n            System.out.println("\\tattached book store id: " + e.getAttachedTargetId());\n        } else if (e.isChanged(BookStoreProps.BOOKS)) {\n            System.out.println("The one-to-many association `BookStore.books` is changed");\n            System.out.println("\\tbook store id: " + e.getSourceId());\n            System.out.println("\\tdetached book id: " + e.getDetachedTargetId());\n            System.out.println("\\tattached book id: " + e.getAttachedTargetId());\n        }\n    }\n}\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="DatabaseListener.kt"',title:'"DatabaseListener.kt"'},'@Component\nclass DatabaseListener {\n\n    // highlight-next-line\n    @EventListener\n    fun onEntityChanged(e: EntityEvent<*>) {\n        if (e.ImmutableType.javaClass == Book::class.java) {\n            println("The object `Book` is changed")\n            println("\\told: ${e.oldEntity}")\n            println("\\tnew: ${e.newEntity}")\n        }\n    }\n\n    // highlight-next-line\n    @EventListener\n    fun onAssociationChanged(e: AssociationEvent) {\n        if (e.isChanged(Book::store)) {\n            println("The many-to-one association `Book.store` is changed")\n            println("\\tbook id: ${e.sourceId}")\n            println("\\tdetached book store id: ${e.detachedTargetId}")\n            println("\\tattached book store id: ${e.attachedTargetId}")\n        } else if (e.isChanged(BookStore::books)) {\n            println("The one-to-many association `BookStore.books` is changed")\n            println("\\tbook store id: ${e.sourceId}")\n            println("\\tdetached book id: ${e.detachedTargetId}")\n            println("\\tattached book id: ${e.attachedTargetId}")\n        }\n    }\n}\n'))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Using Low Level API"),(0,i.kt)("p",{parentName:"li"},"If not using the Jimmer Spring Boot starter, need to manually register event handler code:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// highlight-next-line\nsqlClient.getTriggers().addEntityListener(Book.class, e -> {\n    System.out.println("The object `Book` is changed");\n    System.out.println("\\told: " + e.getOldEntity());\n    System.out.println("\\tnew: " + e.getNewEntity());\n});\n// highlight-next-line\nsqlClient.getTriggers().addAssociationListener(BookProps.STORE, e -> {\n    System.out.println("The many-to-one association `Book.store` is changed");\n    System.out.println("\\tbook id: " + e.getSourceId());\n    System.out.println("\\tdetached book store id: " + e.getDetachedTargetId());\n    System.out.println("\\tattached book store id: " + e.getAttachedTargetId());\n});\n// highlight-next-line\nsqlClient.getTriggers().addAssociationListener(BookStoreProps.BOOKS, e -> {\n    System.out.println("The one-to-many association `BookStore.books` is changed");\n    System.out.println("\\tbook store id: " + e.getSourceId());\n    System.out.println("\\tdetached book id: " + e.getDetachedTargetId());\n    System.out.println("\\tattached book id: " + e.getAttachedTargetId());\n});\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'// highlight-next-line\nsqlClient.triggers.addEntityListener(Book::class) {\n    println("The object `Book` is changed")\n    println("\\told: ${e.oldEntity}")\n    println("\\tnew: ${e.newEntity}")\n}\n// highlight-next-line\nsqlClient.triggers.addAssociationListener(Book::store) {\n    println("The many-to-one association `Book.store` is changed")\n    println("\\tbook id: ${e.sourceId}")\n    println("\\tdetached book store id: ${e.detachedTargetId}")\n    println("\\tattached book store id: ${e.attachedTargetId}")\n}\n// highlight-next-line\nsqlClient.triggers.addAssociationListener(BookStore::books) {\n    println("The one-to-many association `BookStore.books` is changed")\n    println("\\tbook store id: ${e.sourceId}")\n    println("\\tdetached book id: ${e.detachedTargetId}")\n    println("\\tattached book id: ${e.attachedTargetId}") \n}\n')))),(0,i.kt)("p",{parentName:"li"},"Where ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.triggers")," is used to register handler logic to the default trigger."),(0,i.kt)("p",{parentName:"li"},"Can also replace ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.getTriggers()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlClient.triggers")," with ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"sqlClient.getTriggers(true)"))," to register handler logic to the Transaction trigger."))),(0,i.kt)("h3",{id:"experience-triggers"},"Experience Triggers"),(0,i.kt)("p",null,"Now we trigger events to experience triggers."),(0,i.kt)("p",null,"The BinLog trigger can listen to database changes caused by any reason, even if the database is modified by bypassing the application using any other means. "),(0,i.kt)("p",null,"For example, you can directly execute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK set STORE_ID = 2 where ID = 7;\n")),(0,i.kt)("p",null,"However, to send events to the Transaction trigger, the database must be modified through Jimmer's API, for example:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookTable table = Tables.BOOK_TABLE;\nsqlClient\n    .createUpdate(book)\n    .set(table.store().id(), 2L)\n    .where(table.id().eq(7L))\n    .execute();\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .createUpdate(Book::class) {\n        set(table.store.id, 2L)\n        where(table.id eq 7L)\n    }\n    .execute()\n")))),(0,i.kt)("p",null,"The output is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'The object `Book` is changed \u2776\n    old: {"id":7,"name":"Programming TypeScript","edition":1,"price":47.50,"store":{"id":1}}\n    new: {"id":7,"name":"Programming TypeScript","edition":1,"price":47.50,"store":{"id":2}}\nThe many-to-one association `Book.store` is changed \u2777  \n    book id: 7\n    detached book store id: 1\n    attached book store id: 2\nThe one-to-many association `BookStore.books` is changed \u2778\n    book store id: 1\n    detached book id: 7\n    attached book id: null\nThe one-to-many association `BookStore.books` is changed \u2779\n    book store id: 2\n    detached book id: null\n    attached book id: 7\n')),(0,i.kt)("p",null,"Where: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 Represents object change event")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777, \u2778 and \u2779 Represent association change events"))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Jimmer triggers can not only simply convert table changes into object change events, but also convert foreign key changes and middle table changes into association change events.  ")))}g.isMDXComponent=!0}}]);