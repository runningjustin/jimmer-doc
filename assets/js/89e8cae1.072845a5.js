"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[7410],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,k=d["".concat(s,".").concat(u)]||d[u]||c[u]||i;return n?a.createElement(k,r(r({ref:t},m),{},{components:n})):a.createElement(k,r({ref:t},m))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(67294),o=n(34334);const i="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,r),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(83117),o=n(67294),i=n(34334),r=n(72389),l=n(67392),s=n(7094),p=n(12466);const m="tabList__CuJ",c="tabItem_LNqP";function d(e){var t;const{lazy:n,block:r,defaultValue:d,values:u,groupId:k,className:h}=e,g=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=u??g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),b=(0,l.l)(v,((e,t)=>e.value===t.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const N=null===d?d:d??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==N&&!v.some((e=>e.value===N)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${N}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:y}=(0,s.U)(),[C,T]=(0,o.useState)(N),B=[],{blockElementScrollPositionUntilNextRender:S}=(0,p.o5)();if(null!=k){const e=f[k];null!=e&&e!==C&&v.some((t=>t.value===e))&&T(e)}const w=e=>{const t=e.currentTarget,n=B.indexOf(t),a=v[n].value;a!==C&&(S(t),T(a),null!=k&&y(k,String(a)))},x=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=B.indexOf(e.currentTarget)+1;n=B[t]??B[0];break}case"ArrowLeft":{const t=B.indexOf(e.currentTarget)-1;n=B[t]??B[B.length-1];break}}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,i.Z)("tabs-container",m)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":r},h)},v.map((e=>{let{value:t,label:n,attributes:r}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:e=>B.push(e),onKeyDown:x,onFocus:w,onClick:w},r,{className:(0,i.Z)("tabs__item",c,null==r?void 0:r.className,{"tabs__item--active":C===t})}),n??t)}))),n?(0,o.cloneElement)(g.filter((e=>e.props.value===C))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==C})))))}function u(e){const t=(0,r.Z)();return o.createElement(d,(0,a.Z)({key:String(t)},e))}},30464:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var a=n(83117),o=(n(67294),n(3905)),i=n(65488),r=n(85162);const l={sidebar_position:1,title:"Complex Calculation"},s=void 0,p={unversionedId:"mapping/advanced/calculated/transient",id:"mapping/advanced/calculated/transient",title:"Complex Calculation",description:"@Transient Annotation",source:"@site/docs/mapping/advanced/calculated/transient.mdx",sourceDirName:"mapping/advanced/calculated",slug:"/mapping/advanced/calculated/transient",permalink:"/jimmer-doc/docs/mapping/advanced/calculated/transient",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/tree/main/docs/mapping/advanced/calculated/transient.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Complex Calculation"},sidebar:"tutorialSidebar",previous:{title:"Formula",permalink:"/jimmer-doc/docs/mapping/advanced/calculated/formula"},next:{title:"Enum Mapping",permalink:"/jimmer-doc/docs/mapping/advanced/enum"}},m={},c=[{value:"@Transient Annotation",id:"transient-annotation",level:2},{value:"Scalar Calculation: <code>BookStore.avgPrice</code>",id:"scalar-calculation-bookstoreavgprice",level:2},{value:"Define Resolver for <code>avgPrice</code>",id:"define-resolver-for-avgprice",level:3},{value:"Implement Resolver for <code>avgPrice</code>",id:"implement-resolver-for-avgprice",level:3},{value:"Define <code>avgPrice</code>",id:"define-avgprice",level:3},{value:"Fetch <code>avgPrice</code>",id:"fetch-avgprice",level:3},{value:"Associative Calculation: <code>BookStore.newestBooks</code>",id:"associative-calculation-bookstorenewestbooks",level:2},{value:"Clarify Requirements",id:"clarify-requirements",level:3},{value:"Define Resolver for <code>newestBooks</code>",id:"define-resolver-for-newestbooks",level:3},{value:"Implement Resolver for <code>newestBooks</code>",id:"implement-resolver-for-newestbooks",level:3},{value:"Define <code>newestBooks</code>",id:"define-newestbooks",level:3},{value:"Fetch <code>newestBooks</code>",id:"fetch-newestbooks",level:3}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"transient-annotation"},"@Transient Annotation"),(0,o.kt)("p",null,"Jimmer entities can use ",(0,o.kt)("inlineCode",{parentName:"p"},"@org.babyfish.jimmer.sql.Transient")," to define a property unrelated to the database table structure."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStore.java"',title:'"BookStore.java"'},"package com.example.model;\n\nimport org.babyfish.jimmer.sql.*;\n\npublic interface BookStore {\n    \n    ...Omit other properties...\n\n    @Transient\n    Object customData();\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStore.kt"',title:'"BookStore.kt"'},"package com.example.model\n\nimport org.babyfish.jimmer.sql.*\n\ninterface BookStore {\n\n    ...Omit other properties...\n\n    @Transient\n    val customData: Any?\n}\n")))),(0,o.kt)("p",null,"Here, no parameters are specified for the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Tranisent")," annotation, so the current data is just custom user data unrelated to any ORM behavior."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Only when parameters are specified for the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient")," annotation will the current property be a complex calculation property.")),(0,o.kt)("p",null,"So what are the parameters of the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient")," annotation?"),(0,o.kt)("p",null,"Jimmer provides an interface for complex calculation properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Java: ",(0,o.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.TransientResolver<ID, V>")),(0,o.kt)("li",{parentName:"ul"},"Kotlin: ",(0,o.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.kt.KTransientResolver<ID, V>"))),(0,o.kt)("p",null,"This interface allows users to customize the data calculation process."),(0,o.kt)("p",null,"Users develop a class that implements this interface and have it managed by Spring."),(0,o.kt)("p",null,"How to implement this class will be explained in detail later, but for the purpose of expression here, let's assume the user class that implements this interface is ",(0,o.kt)("inlineCode",{parentName:"p"},"CustomerDataResolver"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient")," annotation parameters should be written as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the project is a single project where entity classes can reference this class, then ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient(CustomerDataResolver.class)")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient(CustomerDataResolver::class)"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the project has multiple subprojects where entity classes cannot reference this class, then ",(0,o.kt)("inlineCode",{parentName:"p"},'@Transient(ref = "customerDataResolver")'),"."),(0,o.kt)("p",{parentName:"li"},'Where the string "customerDataResolver" represents the name of this object in the Spring context.'))),(0,o.kt)("h2",{id:"scalar-calculation-bookstoreavgprice"},"Scalar Calculation: ",(0,o.kt)("inlineCode",{parentName:"h2"},"BookStore.avgPrice")),(0,o.kt)("p",null,"In this section, we will add a calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," with the type ",(0,o.kt)("inlineCode",{parentName:"p"},"java.math.BigDecimal"),"."),(0,o.kt)("h3",{id:"define-resolver-for-avgprice"},"Define Resolver for ",(0,o.kt)("inlineCode",{parentName:"h3"},"avgPrice")),(0,o.kt)("p",null,"Each complex calculation property corresponds to a ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientResolver")," implementation class."),(0,o.kt)("p",null,"Before defining the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice"),", let's first define ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStoreAvgPriceResolver"),":"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStoreAvgPriceResolver.java"',title:'"BookStoreAvgPriceResolver.java"'},"package com.example.business.resolver;\n\nimport org.babyfish.jimmer.sql.*;\nimport org.babyfish.jimmer.sql.TransientResolver;\nimport org.springframework.stereotype.Component;\n\n@Component \npublic class BookStoreAvgPriceResolver implements TransientResolver<Long, BigDecimal> {\n    \n    @Override\n    public Map<Long, BigDecimal> resolve(Collection<Long> ids) {\n        To be implemented later\n    }\n\n    @Override\n    public BigDecimal getDefaultValue() {\n        return BigDecimal.ZERO; \n    }\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStoreAvgPriceResolver.kt"',title:'"BookStoreAvgPriceResolver.kt"'},"package com.example.business.resolver\n\nimport org.babyfish.jimmer.sql.*\nimport org.babyfish.jimmer.sql.kt.KTransientResolver\nimport org.springframework.stereotype.Component\n\n@Component\nclass BookStoreAvgPriceResolver : KTransientResolver<Long, BigDecimal> {\n\n    override fun resolve(ids: Collection<Long>): Map<Long, BigDecimal> {\n        To be implemented later\n    }\n\n    override fun getDefaultValue(): BigDecimal = \n        BigDecimal.ZERO\n}\n")))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The base interface ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientResolver/KTransientResolver")," has two generic parameters:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The 1st generic parameter: The type of the id property of the entity to which the calculation property belongs. "),(0,o.kt)("p",{parentName:"li"},"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," to be defined belongs to the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," entity whose id type is ",(0,o.kt)("inlineCode",{parentName:"p"},"long"),", so the generic parameter here is ",(0,o.kt)("inlineCode",{parentName:"p"},"Long"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The 2nd generic parameter: The return data type of the calculation property.  "),(0,o.kt)("p",{parentName:"li"},"In this example, the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," to be defined is ",(0,o.kt)("inlineCode",{parentName:"p"},"BigDecimal"),", so the generic parameter here is ",(0,o.kt)("inlineCode",{parentName:"p"},"BigDecimal"),".")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," is a method of the base interface that must be implemented for users to complete calculation through it."),(0,o.kt)("admonition",{parentName:"li",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The parameter type of the ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," method is ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<Long>")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"Long"),"; its return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Map<Long, BigDecimal>"),"."),(0,o.kt)("p",{parentName:"admonition"},"This is very important. It means that ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," is not calculated one by one against ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.id"),", but is calculated in batches against multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.id")," at a time."),(0,o.kt)("p",{parentName:"admonition"},"This is designed to prevent the ",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping"},"N+1 problem")," caused by calculation properties."),(0,o.kt)("p",{parentName:"admonition"},"This design is almost the same as ",(0,o.kt)("a",{parentName:"p",href:"https://javadoc.io/doc/com.graphql-java/java-dataloader/2.2.3/org/dataloader/MappedBatchLoader.html"},"MappedBatchLoader")," in the GraphQL field, which is the standard programming model for all similar domains."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"getDefaultValue")," is an optional method of the base interface to implement."),(0,o.kt)("p",{parentName:"li"},"For the ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," method, if the length of the returned Map is less than the length of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ids")," parameter collection passed in, it means some data does not have calculation results. The calculation value corresponding to each such data is considered null."),(0,o.kt)("p",{parentName:"li"},"However, if the calculation property (",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," in this example) is non-null, it will cause problems. Users can override ",(0,o.kt)("inlineCode",{parentName:"p"},"getDefaultValue()")," to return a non-null default value to resolve this issue."),(0,o.kt)("admonition",{parentName:"li",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"For calculation properties that do not allow null, ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientResolver")," must:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Either ensure the keySet of the Map returned by the ",(0,o.kt)("inlineCode",{parentName:"li"},"resolve")," method contains all parameters"),(0,o.kt)("li",{parentName:"ul"},"Or override ",(0,o.kt)("inlineCode",{parentName:"li"},"getDefaultValue")," to return a non-null default value"))))),(0,o.kt)("h3",{id:"implement-resolver-for-avgprice"},"Implement Resolver for ",(0,o.kt)("inlineCode",{parentName:"h3"},"avgPrice")),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStoreAvgPriceResolver.java"',title:'"BookStoreAvgPriceResolver.java"'},"package com.example.business.resolver;\n\nimport org.babyfish.jimmer.sql.*;\nimport org.babyfish.jimmer.sql.ast.tuple.Tuple2;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BookStoreAvgPriceResolver implements TransientResolver<Long, BigDecimal> {\n\n    private final JSqlClient sqlClient;\n\n    // Constructor injection\n    public BookStoreAvgPriceResolver(JSqlClient sqlClient) {\n        this.sqlClient = bookStoreRepository; \n    }\n    \n    @Override  \n    public Map<Long, BigDecimal> resolve(Collection<Long> ids) {\n        return Tuple2.toMap(\n            sqlClient\n                .createQuery(table) \n                .where(table.storeId().in(storeIds)) \u2776\n                .groupBy(table.storeId()) \u2777\n                .select(\n                    table.storeId(),  \n                    table.price().avg() \u2778\n                )\n                .execute()\n        );\n    }\n\n    ...Omit other methods...\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStoreAvgPriceResolver.kt"',title:'"BookStoreAvgPriceResolver.kt"'},"package com.example.business.resolver\n\nimport org.babyfish.jimmer.sql.*\nimport org.babyfish.jimmer.sql.kt.*\nimport org.springframework.stereotype.Component\n\n@Component\nclass BookStoreAvgPriceResolver(\n    // Constructor injection\n    private val sqlClient: KSqlClient  \n) : KTransientResolver<Long, BigDecimal> {\n\n    override fun resolve(ids: Collection<Long>): Map<Long, BigDecimal> =\n        sqlClient\n            .createQuery(Book::class) {\n                where(table.store.id valueIn storeIds) \u2776\n                groupBy(table.store.id) \u2777\n                select(\n                    table.store.id,\n                    avg(table.price).asNonNull() \u2778 \n                )\n            }\n            .execute()\n            .associateBy({it._1}) {\n                it._2\n            }\n\n    ...Omit other functions...\n}\n")))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2776 Filter the foreign key ",(0,o.kt)("inlineCode",{parentName:"p"},"STORE_ID")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK")," table to limit the query scope. Only calculate the average price of books under the bookstores that need calculation at the moment, not all bookstores in the database.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2777 Group by the foreign key ",(0,o.kt)("inlineCode",{parentName:"p"},"STORE_ID")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK")," table.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2778 Calculate the average of book prices within each group."),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"avg"),": Calculate the average of ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.price")," within the group."),(0,o.kt)("admonition",{parentName:"li",type:"note"},(0,o.kt)("p",{parentName:"admonition"},"In the Kotlin code there is an ",(0,o.kt)("inlineCode",{parentName:"p"},"asNonNull()"),"."),(0,o.kt)("p",{parentName:"admonition"},"According to SQL standards, if the aggregate function ",(0,o.kt)("inlineCode",{parentName:"p"},"avg")," is not used with group, its return value can be null without original data. So in Kotlin ",(0,o.kt)("inlineCode",{parentName:"p"},"avg")," is defined to return a nullable type. "),(0,o.kt)("p",{parentName:"admonition"},"However, when the aggregate function ",(0,o.kt)("inlineCode",{parentName:"p"},"avg")," is used with group, it cannot return null. So ",(0,o.kt)("inlineCode",{parentName:"p"},"asNonNull()")," is called to get a non-null expression.")))),(0,o.kt)("h3",{id:"define-avgprice"},"Define ",(0,o.kt)("inlineCode",{parentName:"h3"},"avgPrice")),(0,o.kt)("p",null,"Now that the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStoreAvgPriceResolver")," class is complete, we can add the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"avgPrice")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," entity:"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStore.java"',title:'"BookStore.java"'},"package com.example.model;\n\nimport com.example.business.resolver.BookStoreAvgPriceResolver; \u2776\n\nimport org.babyfish.jimmer.sql.*;\n\npublic interface BookStore {\n    \n    ...Omit other properties...\n\n    @Transient(BookStoreAvgPriceResolver.class) \u2777\n    BigDecimal avgPrice();\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStore.kt"',title:'"BookStore.kt"'},"package com.example.model\n\nimport com.example.business.resolver.BookStoreAvgPriceResolver \u2776\n\nimport org.babyfish.jimmer.sql.*\n\ninterface BookStore {\n\n    ...Omit other properties...\n\n    @Transient(BookStoreAvgPriceResolver::class) \u2777\n    val avgPrice: BigDecimal\n}\n")))),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If it is a single project, the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStoreAvgPriceResolver")," class can be referenced here.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Define the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice"),", and specify the class introduced at \u2776 for its ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient")," annotation to tell Jimmer the calculation rule for the calculation property."),(0,o.kt)("admonition",{parentName:"li",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If it is a multi-project where the code structure has been split, the import statement at \u2776 is invalid. In this case, \u2777 must be ",(0,o.kt)("inlineCode",{parentName:"p"},'@Transient(ref = "bookStoreAvgPriceResolver")'),". "),(0,o.kt)("p",{parentName:"admonition"},"That is, use the name of this object in the Spring context.")))),(0,o.kt)("h3",{id:"fetch-avgprice"},"Fetch ",(0,o.kt)("inlineCode",{parentName:"h3"},"avgPrice")),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<BookStore> stores = bookStoreRepository.findAll(\n    Fetchers.BOOK_STORE_FETCHER\n        .name()\n        // highlight-next-line\n        .avgPrice()\n);\nSystem.out.println(stores);\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val stores = bookStoreRepository.findAll(\n    newFetcher(BookStore::class).by {\n        name()\n        // highlight-next-line\n        avgPrice()\n    }\n)\nprintln(stores)\n")))),(0,o.kt)("p",null,"Printed result:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id":2,\n        "name":"MANNING",\n        // highlight-next-line\n        "avgPrice":80.333333333333\n    },\n    {\n        "id":1,\n        "name":"O\'REILLY",\n        // highlight-next-line\n        "avgPrice":57.944444444444\n    }\n]\n')),(0,o.kt)("p",null,"Executed SQL:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"/* Step 1: Query aggregate root objects, i.e. BookStore */  \nselect tb_1_.ID, tb_1_.NAME from BOOK_STORE as tb_1_\n\n/* Step 2: Calculate `avgPrice` property for BookStore objects with id 1 and 2 */\nselect\n    tb_1_.STORE_ID, \n    /* highlight-next-line */\n    avg(tb_1_.PRICE)\nfrom BOOK tb_1_ \nwhere\n    /* highlight-next-line */\n    tb_1_.STORE_ID in (\n        ? /* 2 */, ? /* 1 */  \n    )\ngroup by\n    /* highlight-next-line */  \n    tb_1_.STORE_ID\n")),(0,o.kt)("h2",{id:"associative-calculation-bookstorenewestbooks"},"Associative Calculation: ",(0,o.kt)("inlineCode",{parentName:"h2"},"BookStore.newestBooks")),(0,o.kt)("h3",{id:"clarify-requirements"},"Clarify Requirements"),(0,o.kt)("p",null,"In the previous section we demonstrated the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice"),", which is obviously a non-associative property."),(0,o.kt)("p",null,"In this section, we will add a calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," with the type ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.List<Book>"),", which is clearly an association property."),(0,o.kt)("p",null,"To explain why this example needs to add a calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks"),", let's first look at the characteristics of the original association property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.books"),":"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Book store = bookStoreRepository.findNullable(\n    1L,  \n    Fetchers.BOOK_STORE_FETCHER\n        .name()\n        .books(\n            Fetchers.BOOK_FETCHER\n                .name()\n                .edition()\n        )\n);\nSystem.out.println(store);\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val store = bookStoreRepository.findNullable(\n    1L,\n    newFetcher(BookStore::class).by {\n        name()\n        books {\n            name()\n            edition()\n        }\n    }\n)  \nprintln(store)\n")))),(0,o.kt)("p",null,"The query result is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id":1,\n    "name":"O\'REILLY", \n    "books":[\n        {\n            "id":6,\n            "name":"Effective TypeScript",\n            "edition":3\n        },\n        {\n            "id":5,\n            "name":"Effective TypeScript",\n            "edition":2\n        },\n        {\n            "id":4,\n            "name":"Effective TypeScript",\n            "edition":1\n        },\n        {\n            "id":3,\n            "name":"Learning GraphQL",\n            "edition":3  \n        },\n        {\n            "id":2,\n            "name":"Learning GraphQL",\n            "edition":2\n        },\n        {\n            "id":1,\n            "name":"Learning GraphQL",\n            "edition":1\n        },\n        {\n            "id":9, \n            "name":"Programming TypeScript",\n            "edition":3\n        },\n        {\n            "id":8,\n            "name":"Programming TypeScript",\n            "edition":2\n        },\n        {\n            "id":7,\n            "name":"Programming TypeScript",\n            "edition":1\n        }\n    ]\n}\n')),(0,o.kt)("p",null,"We can see that in the original ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.books")," association, there are many books with the same name in the bookstore. "),(0,o.kt)("p",null,'For example, there are a total of three books named "Effective TypeScript", with different ',(0,o.kt)("inlineCode",{parentName:"p"},"edition")," values: 3, 2, 1."),(0,o.kt)("p",null,"Now we want to create a new calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks")," through calculation. It ensures that the returned book collection has no duplicate name problem. For each unique book name, only the book with the highest ",(0,o.kt)("inlineCode",{parentName:"p"},"edition"),", i.e. the maximum ",(0,o.kt)("inlineCode",{parentName:"p"},"edition"),", is taken."),(0,o.kt)("h3",{id:"define-resolver-for-newestbooks"},"Define Resolver for ",(0,o.kt)("inlineCode",{parentName:"h3"},"newestBooks")),(0,o.kt)("p",null,"Each complex calculation property corresponds to a ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientResolver")," implementation class."),(0,o.kt)("p",null,"Before defining the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks"),", let's first define ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStoreNewestBooksResolver"),":"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStoreNewestBooksResolver.java"',title:'"BookStoreNewestBooksResolver.java"'},"package com.example.business.resolver;\n\nimport org.babyfish.jimmer.sql.*;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BookStoreNewestBooksResolver implements TransientResolver<Long, List<Long>> { \u2776\n    \n    @Override\n    public Map<Long, List<Long>> resolve(Collection<Long> ids) { \u2777\n        ...To be implemented later...\n    }\n\n    @Override\n    public BigDecimal getDefaultValue() {\n        Collections.emptyList(); \n    }\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"package com.example.business.resolver\n\nimport org.babyfish.jimmer.sql.kt.*\nimport org.springframework.stereotype.Component\n\n@Component\nclass BookStoreNewestBooksResolver : KTransientResolver<Long, List<Long>> { \u2776\n\n    override fun resolve(ids: Collection<Long>): Map<Long, List<Long>> { \u2777\n        ...To be implemented later...\n    }\n\n    override fun getDefaultValue(): BigDecimal =\n        emptyList()\n}\n")))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2776 The base interface ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientResolver/KTransientResolver")," has two generic parameters:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The 1st generic parameter: The type of the id property of the entity to which the calculation property belongs.  "),(0,o.kt)("p",{parentName:"li"},"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks")," to be defined belongs to the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," entity whose id type is ",(0,o.kt)("inlineCode",{parentName:"p"},"long"),", so the generic parameter here is ",(0,o.kt)("inlineCode",{parentName:"p"},"Long"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The 2nd generic parameter: The return data type of the calculation property. "),(0,o.kt)("p",{parentName:"li"},"In this example, the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks")," to be defined is ",(0,o.kt)("inlineCode",{parentName:"p"},"List<Book>"),"."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Since it is a collection type, the generic parameter contains ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," here.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"Book")," is an entity type. Jimmer stipulates that the entity type here needs to be replaced with its id type, and ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.id")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"long"),"."))),(0,o.kt)("p",{parentName:"li"},"In summary, the 2nd generic parameter is ",(0,o.kt)("inlineCode",{parentName:"p"},"List<Long>"),".")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2777 ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," is a method of the base interface that must be implemented for users to complete calculation through it."),(0,o.kt)("admonition",{parentName:"li",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The parameter type of the ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," method is ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<Long>")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"Long"),"; its return type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Map<Long, List<Long>>"),"."),(0,o.kt)("p",{parentName:"admonition"},"This is very important. It means that ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks")," is not calculated one by one against ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.id"),", but is calculated in batches against multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.id")," at a time."),(0,o.kt)("p",{parentName:"admonition"},"This is designed to prevent the ",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping"},"N+1 problem")," caused by calculation properties."),(0,o.kt)("p",{parentName:"admonition"},"This design is almost the same as ",(0,o.kt)("a",{parentName:"p",href:"https://javadoc.io/doc/com.graphql-java/java-dataloader/2.2.3/org/dataloader/MappedBatchLoader.html"},"MappedBatchLoader")," in the GraphQL field, which is the standard programming model for all similar domains."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2778 ",(0,o.kt)("inlineCode",{parentName:"p"},"getDefaultValue")," is an optional method of the base interface to implement."),(0,o.kt)("p",{parentName:"li"},"For the ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," method, if the length of the returned Map is less than the length of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ids")," parameter collection passed in, it means some data does not have calculation results. The calculation value corresponding to each such data is considered null."),(0,o.kt)("p",{parentName:"li"},"However, if the calculation property (",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks")," in this example) is non-null, it will cause problems. Users can override ",(0,o.kt)("inlineCode",{parentName:"p"},"getDefaultValue()")," to return a non-null default value to resolve this issue."),(0,o.kt)("admonition",{parentName:"li",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If calculation properties do not allow null, for their ",(0,o.kt)("inlineCode",{parentName:"p"},"TransientResolver")," implementations:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Either ensure the keySet of the Map returned by the ",(0,o.kt)("inlineCode",{parentName:"li"},"resolve")," method contains all parameters"),(0,o.kt)("li",{parentName:"ul"},"Or override ",(0,o.kt)("inlineCode",{parentName:"li"},"getDefaultValue")," to return a non-null default value"))))),(0,o.kt)("h3",{id:"implement-resolver-for-newestbooks"},"Implement Resolver for ",(0,o.kt)("inlineCode",{parentName:"h3"},"newestBooks")),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package com.example.business.resolver;\n\nimport java.util.Collections;\n\nimport org.babyfish.jimmer.sql.*;\nimport org.babyfish.jimmer.sql.ast.tuple.Tuple2;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class BookStoreNewestBooksResolver implements TransientResolver<Long, List<Long>> {\n\n    private final JSqlClient sqlClient;\n\n    // Constructor injection\n    public BookStoreAvgPriceResolver(JSqlClient sqlClient) {\n        this.sqlClient = sqlClient;\n    }\n    \n    @Override\n    public Map<Long, BigDecimal> resolve(Collection<Long> ids) {\n        return Tuple2.toMultiMap(\n            sqlClient\n                .createQuery(table)\n                .where(\n                    Expression.tuple( \u2776\n                        table.name(),  \n                        table.edition()\n                    ).in(\n                        sqlClient.createSubQuery(table) \u2777\n                            .where(table.storeId().in(ids)) \u2778\n                            .groupBy(table.name()) \u2779\n                            .select(\n                                table.name(),\n                                table.edition().max() \u277a  \n                            )\n                    )\n                )\n                .select(\n                    table.storeId(),\n                    table.id()\n                )\n                .execute()\n        );\n    }\n\n    ...Omit other code...\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"package com.example.business.resolver\n\nimport org.babyfish.jimmer.sql.kt.*\nimport org.springframework.stereotype.Component\n\n@Component\nclass BookStoreNewestBooksResolver(\n    // Constructor injection\n    private val sqlClient: KSqlClient\n) : KTransientResolver<Long, List<Long>> {\n\n    override fun resolve(ids: Collection<Long>): Map<Long, BigDecimal> =\n        sqlClient\n            .createQuery(Book::class) {\n                where(\n                    tuple( \u2776\n                        table.name,\n                        table.edition  \n                    ) valueIn subQuery(Book::class) { \u2777\n                        where(table.store.id valueIn storeIds) \u2778\n                        groupBy(table.name) \u2779\n                        select(\n                            table.name,\n                            max(table.edition).asNonNull() \u277a\n                        )\n                    }\n                )\n                select(\n                    table.store.id,\n                    table.id\n                )\n            }\n            .execute()\n            .groupBy({it._1}) {\n                it._2\n            }\n\n    ...Omit other code...\n}\n")))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2776 ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.edition")," form an SQL tuple.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2777 The tuple has two columns of type String and int. The subquery also has two columns of type String and int. The two match perfectly and can use the in operator.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2778 Limit the query scope to only calculate the latest version of books that need to be queried at the moment, not all bookstores in the database."),(0,o.kt)("p",{parentName:"li"},"Imposing calculation scope limiting conditions on the subquery performs better than imposing them on the parent query.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2779 Group by book name, so books of the same name must belong to the same group.  ")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u277a For each group of books with the same name, find the maximum ",(0,o.kt)("inlineCode",{parentName:"p"},"edition"),"."))),(0,o.kt)("h3",{id:"define-newestbooks"},"Define ",(0,o.kt)("inlineCode",{parentName:"h3"},"newestBooks")),(0,o.kt)("p",null,"Now that the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStoreNewestBooksResolver")," class is complete, we can add the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"newestBooks")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," entity:"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package com.example.model;\n\nimport com.example.business.resolver.BookStoreNewestBooksResolver; \u2776\n\nimport org.babyfish.jimmer.sql.*;\n\npublic interface BookStore {\n    \n    ...Omit other properties...\n\n    @Transient(BookStoreNewestBooksResolver.class) \u2777\n    List<Book> newestBooks();\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"package com.example.model\n\nimport com.example.business.resolver.BookStoreNewestBooksResolver \u2776\n\nimport org.babyfish.jimmer.sql.*\n\ninterface BookStore {\n\n    ...Omit other properties...\n\n    @Transient(BookStoreNewestBooksResolver::class) \u2777\n    val newestBooks: List<Book> \n}\n")))),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If it is a single project, the ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStoreNewestBooksResolver")," class can be referenced here.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Define the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks"),", and specify the class introduced at \u2776 for its ",(0,o.kt)("inlineCode",{parentName:"p"},"@Transient")," annotation to tell Jimmer the calculation rule for the calculation property."),(0,o.kt)("admonition",{parentName:"li",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If it is a multi-project where the code structure has been split, the import statement at \u2776 is invalid. In this case, \u2777 must be ",(0,o.kt)("inlineCode",{parentName:"p"},'@Transient(ref = "bookStoreNewestBooksResolver")'),"."),(0,o.kt)("p",{parentName:"admonition"},"That is, use the name of this object in the Spring context.")))),(0,o.kt)("h3",{id:"fetch-newestbooks"},"Fetch ",(0,o.kt)("inlineCode",{parentName:"h3"},"newestBooks")),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<BookStore> stores = bookStoreRepository.findAll(\n    Fetchers.BOOK_STORE_FETCHER\n        .name()\n        .newestBooks( \u2776\n\n            \u2777\n            Fetchers.BOOK_FETCHER\n                allScalarFields()\n                .authors(\n                    Fetchers.AUTHOR_FETCHER\n                        .allScalarFields()\n                )\n        )\n);\nSystem.out.println(stores); \n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val stores = bookStoreRepository.findAll(\n    newFetcher(BookStore::class).by {\n        name()\n        newestBooks { \u2776\n\n            \u2777\n            allScalarFields()\n            authors {\n                allScalarFields()\n            }\n        }\n    }\n)\nprintln(stores)\n")))),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Fetch the calculation property ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.newestBooks"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"The calculation property itself is also an association property, so the shape of its associated objects can be controlled by a deeper child fetcher."))),(0,o.kt)("p",null,"The printed result is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id":2,\n        "name":"MANNING",\n        /* highlight-next-line */\n        "newestBooks":[\n            {\n                "id":12,\n                "name":"GraphQL in Action",\n                /* highlight-next-line */\n                "edition":3, // This edition is max, no duplicate names\n                "price":80,\n                "authors":[\n                    {\n                        "id":5,\n                        "firstName":"Samer",\n                        "lastName":"Buna",\n                        "gender":"MALE"\n                    }\n                ]\n            }\n        ]\n    },\n    {\n        "id":1,\n        "name":"O\'REILLY",\n        /* highlight-next-line */ \n        "newestBooks":[\n            {\n                "id":3,\n                "name":"Learning GraphQL",\n                /* highlight-next-line */\n                "edition":3, // This edition is max, no duplicate names\n                "price":51,\n                "authors":[\n                    {\n                        "id":2,\n                        "firstName":"Alex",\n                        "lastName":"Banks",\n                        "gender":"MALE"\n                    },\n                    {\n                        "id":1,\n                        "firstName":"Eve",\n                        "lastName":"Procello",\n                        "gender":"FEMALE"\n                    }\n                ]\n            },\n            {\n                "id":6,\n                "name":"Effective TypeScript",\n                /* highlight-next-line */\n                "edition":3, // This edition is max, no duplicate names\n                "price":88,\n                "authors":[\n                    {\n                        "id":3,\n                        "firstName":"Dan",\n                        "lastName":"Vanderkam",\n                        "gender":"MALE"\n                    }\n                ]\n            },\n            {\n                "id":9,\n                "name":"Programming TypeScript",\n                /* highlight-next-line */\n                "edition":3, // This edition is max, no duplicate names\n                "price":48,\n                "authors":[\n                    {\n                        "id":4,\n                        "firstName":"Boris",\n                        "lastName":"Cherny",\n                        "gender":"MALE"\n                    }\n                ]\n            }\n        ]\n    }\n]\n')),(0,o.kt)("p",null,"The generated SQL is: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"/* Step 1: Query aggregate root objects, i.e. BookStore */\nselect tb_1_.ID, tb_1_.NAME from BOOK_STORE as tb_1_\n\n/* Step 2: For BookStore objects with id 1 and 2, calculate id sets of all Books that `newestBooks` can associate to */ \n/* highlight-start */\nselect\n    tb_1_.STORE_ID,\n    tb_1_.ID\nfrom BOOK tb_1_\nwhere\n    (tb_1_.NAME, tb_1_.EDITION) in (\n        select\n            tb_3_.NAME, \n            max(tb_3_.EDITION)\n        from BOOK tb_3_\n        where\n            tb_3_.STORE_ID in (\n                ? /* 2 */, ? /* 1 */  \n            )\n        group by\n            tb_3_.NAME\n    )\n/* highlight-end */\n\n/* Step 3: For associated Book ids, query non-associative fields */\nselect\n    tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE\nfrom BOOK as tb_1_\nwhere tb_1_.ID in (?, ?, ?, ?)  \n\n/* Step 4: For associated Books, query associable Authors */  \nselect\n    tb_2_.BOOK_ID, tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME, tb_1_.GENDER\nfrom AUTHOR as tb_1_\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere\n    tb_2_.BOOK_ID in (?, ?, ?, ?) \n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"This example shows that when the calculation property itself is also an association property, the shape of its associated objects can be controlled by a deeper child fetcher."),(0,o.kt)("p",{parentName:"admonition"},"Since there is a deeper child fetcher, of course both native ORM association properties and other calculation association properties can be included."),(0,o.kt)("p",{parentName:"admonition"},"That is, in the process of querying complex data structures by object fetchers, the fetching tasks of ORM association properties and calculation association properties can be arbitrarily mixed."),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The fetching task of ORM association properties is actually SQL operations."),(0,o.kt)("p",{parentName:"li"},"(At least before we introduce cache, it can be considered so)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"As mentioned earlier, Jimmer does not impose any restrictions on the calculation methods of calculation properties. You can even use any technology other than SQL, such as OLAP technologies, to implement the calculation process (this documentation focuses on Jimmer itself, so examples also use Jimmer to implement the calculation process)."),(0,o.kt)("p",{parentName:"li"},"That is, the fetching task of calculation properties is not necessarily SQL operations."))),(0,o.kt)("p",{parentName:"admonition"},"Therefore, the functionality provided by object fetchers is actually an arbitrary mix of SQL and non-SQL operations.")))}u.isMDXComponent=!0}}]);