"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[1772],{85162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(67294),l=a(34334);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,l.Z)(i,o),hidden:a},t)}},65488:(e,t,a)=>{a.d(t,{Z:()=>c});var n=a(83117),l=a(67294),i=a(34334),o=a(72389),r=a(67392),s=a(7094),p=a(12466);const u="tabList__CuJ",m="tabItem_LNqP";function b(e){var t;const{lazy:a,block:o,defaultValue:b,values:c,groupId:d,className:k}=e,h=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=c??h.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),N=(0,r.l)(g,((e,t)=>e.value===t.value));if(N.length>0)throw new Error(`Docusaurus error: Duplicate values "${N.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const T=null===b?b:b??(null==(t=h.find((e=>e.props.default)))?void 0:t.props.value)??h[0].props.value;if(null!==T&&!g.some((e=>e.value===T)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${T}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:y}=(0,s.U)(),[v,x]=(0,l.useState)(T),_=[],{blockElementScrollPositionUntilNextRender:E}=(0,p.o5)();if(null!=d){const e=f[d];null!=e&&e!==v&&g.some((t=>t.value===e))&&x(e)}const j=e=>{const t=e.currentTarget,a=_.indexOf(t),n=g[a].value;n!==v&&(E(t),x(n),null!=d&&y(d,String(n)))},B=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{const t=_.indexOf(e.currentTarget)+1;a=_[t]??_[0];break}case"ArrowLeft":{const t=_.indexOf(e.currentTarget)-1;a=_[t]??_[_.length-1];break}}null==(t=a)||t.focus()};return l.createElement("div",{className:(0,i.Z)("tabs-container",u)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":o},k)},g.map((e=>{let{value:t,label:a,attributes:o}=e;return l.createElement("li",(0,n.Z)({role:"tab",tabIndex:v===t?0:-1,"aria-selected":v===t,key:t,ref:e=>_.push(e),onKeyDown:B,onFocus:j,onClick:j},o,{className:(0,i.Z)("tabs__item",m,null==o?void 0:o.className,{"tabs__item--active":v===t})}),a??t)}))),a?(0,l.cloneElement)(h.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},h.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==v})))))}function c(e){const t=(0,o.Z)();return l.createElement(b,(0,n.Z)({key:String(t)},e))}},32102:(e,t,a)=>{a.d(t,{s:()=>k});var n=a(83117),l=a(67294),i=a(42293),o=a(50657),r=a(6514),s=a(54776),p=a(10155),u=a(15861),m=a(93946),b=a(9137),c=a(61274),d=a(50594);const k=(0,l.memo)((e=>{let{open:t,fullScreen:a=!1,title:n,maxWidth:s="md",onClose:k,children:g}=e;const[N,T]=(0,l.useState)(a),f=(0,l.useCallback)((()=>{T((e=>!e))}),[]);return l.createElement(o.Z,{open:t,onClose:k,fullScreen:N,TransitionComponent:h,maxWidth:s},l.createElement(i.Z,{sx:{position:"relative"}},l.createElement(p.Z,null,l.createElement(u.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},n),l.createElement(m.Z,{onClick:f,style:{color:"white"}},N?l.createElement(c.Z,null):l.createElement(b.Z,null)),l.createElement(m.Z,{"aria-label":"close",onClick:k,style:{color:"white"}},l.createElement(d.Z,null)))),l.createElement(r.Z,null,g))})),h=l.forwardRef((function(e,t){return l.createElement(s.Z,(0,n.Z)({direction:"up",ref:t},e))}))},39511:(e,t,a)=>{a.d(t,{b:()=>o});var n=a(67294),l=a(83321),i=a(32102);const o=(0,n.memo)((e=>{let{buttonText:t,fullScreen:a=!1,title:o=t,variant:r="outlined",maxWidth:s,children:p}=e;const[u,m]=(0,n.useState)(!1),b=(0,n.useCallback)((e=>{m(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),c=(0,n.useCallback)((()=>{m(!1)}),[]);return n.createElement(n.Fragment,null,n.createElement(l.Z,{"data-is-view-more-button":"true",onClick:b,variant:r,size:"small"},t),n.createElement(i.s,{open:u,onClose:c,title:o,maxWidth:s,fullScreen:a},p))}))},24516:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>d,frontMatter:()=>s,metadata:()=>u,toc:()=>b});var n=a(83117),l=(a(67294),a(3905)),i=a(39511),o=a(65488),r=a(85162);const s={sidebar_position:5,title:"Pagination Safety"},p=void 0,u={unversionedId:"query/dynamic-join/table-ex",id:"query/dynamic-join/table-ex",title:"Pagination Safety",description:"Pagination safety is a feature designed for pagination, but table join functionality provides underlying support.",source:"@site/docs/query/dynamic-join/table-ex.mdx",sourceDirName:"query/dynamic-join",slug:"/query/dynamic-join/table-ex",permalink:"/jimmer-doc/docs/query/dynamic-join/table-ex",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/tree/main/docs/query/dynamic-join/table-ex.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Pagination Safety"},sidebar:"tutorialSidebar",previous:{title:"Optimize Unnecessary Joins",permalink:"/jimmer-doc/docs/query/dynamic-join/optimization"},next:{title:"Weak Join",permalink:"/jimmer-doc/docs/query/dynamic-join/weak-join"}},m={},b=[{value:"Problems with Collection Associations",id:"problems-with-collection-associations",level:2},{value:"Collection JOIN Causes Duplicate Results",id:"collection-join-causes-duplicate-results",level:3},{value:"Harms of Duplicate Results",id:"harms-of-duplicate-results",level:3},{value:"Implicit Subqueries",id:"implicit-subqueries",level:2},{value:"Table and TableEx",id:"table-and-tableex",level:2},{value:"Generated Code",id:"generated-code",level:3},{value:"Top-Level Queries Must Be Based on Table",id:"top-level-queries-must-be-based-on-table",level:3},{value:"TableEx Allowed for Subqueries",id:"tableex-allowed-for-subqueries",level:3},{value:"asTableEx",id:"astableex",level:2}],c={toc:b};function d(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Pagination safety is a feature designed for pagination, but table join functionality provides underlying support."),(0,l.kt)("h2",{id:"problems-with-collection-associations"},"Problems with Collection Associations"),(0,l.kt)("p",null,"Here, we first introduce two types of associations: reference associations and collection associations."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Associations decorated with ",(0,l.kt)("inlineCode",{parentName:"p"},"@OneToOne")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"@ManyToOne")," are called reference associations.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Associations decorated with ",(0,l.kt)("inlineCode",{parentName:"p"},"@OneToMany")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"@ManyToMany")," are called collection associations."))),(0,l.kt)("p",null,"Please refer to the example:"),(0,l.kt)(i.b,{buttonText:"Association example",mdxType:"ViewMore"},(0,l.kt)("p",null,"Let's look at this entity definition:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Book.java"',title:'"Book.java"'},'\npackage org.babyfish.jimmer.sql.example.model;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport javax.validation.constraints.Null;\n\nimport org.babyfish.jimmer.sql.*;\n\n@Entity\npublic interface Book {\n\n    @Id\n    long id();\n\n    String name();\n\n    int edition();\n\n    BigDecimal price();\n\n    @Null\n    @ManyToOne\n    // highlight-next-line\n    BookStore store();\n\n    @ManyToMany\n    @JoinTable(\n            name = "BOOK_AUTHOR_MAPPING",\n            joinColumnName = "BOOK_ID",\n            inverseJoinColumnName = "AUTHOR_ID"\n    )\n    // highlight-next-line\n    List<Author> authors();\n}\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Book.kt"',title:'"Book.kt"'},'\npackage org.babyfish.jimmer.sql.example.model\n\nimport java.math.BigDecimal;\n\nimport org.babyfish.jimmer.sql.*;\n\n@Entity\ninterface Book {\n\n    @Id\n    val id: Long\n\n    val name: String\n\n    val edition: Int\n\n    val price: BigDecimal\n\n    @ManyToOne\n    // highlight-next-line\n    val store: BookStore?\n\n    @ManyToMany\n    @JoinTable(\n            name = "BOOK_AUTHOR_MAPPING",\n            joinColumnName = "BOOK_ID",\n            inverseJoinColumnName = "AUTHOR_ID"\n    )\n    // highlight-next-line\n    val authors: List<Author>\n}\n')))),(0,l.kt)("p",null,"In this example:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Book.store")," decorated with ",(0,l.kt)("inlineCode",{parentName:"li"},"@ManyToOne")," is a reference association. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Book.authors")," decorated with ",(0,l.kt)("inlineCode",{parentName:"li"},"@ManyToMany")," is a collection association."))),(0,l.kt)("h3",{id:"collection-join-causes-duplicate-results"},"Collection JOIN Causes Duplicate Results"),(0,l.kt)("p",null,"If we call the entity object corresponding to the first table being queried the aggregate root object, reference associations and collection associations differ in:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Joining tables via a reference association does not produce duplicate records of the current main object in the SQL query result. For example:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    b.id as root_id,\n    b.name as root_name,\n    s.id as associated_id,\n    s.name as associated_name\nfrom book b\ninner join book_store s\n    on b.store_id = s.id\nwhere b.id = 1;\n")),(0,l.kt)("p",{parentName:"li"},"The query result has no duplicate aggregate root objects:"),(0,l.kt)("table",{parentName:"li"},(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"root_id"),(0,l.kt)("th",{parentName:"tr",align:null},"root_name"),(0,l.kt)("th",{parentName:"tr",align:null},"associated_id"),(0,l.kt)("th",{parentName:"tr",align:null},"associated_name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Learning GraphQL"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"O'REILLY"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Joining tables via a collection association produces duplicate records of the current main object in the SQL query result:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    b.id as root_id, \n    b.name as root_name,\n    a.id as associated_id,\n    a.first_name as associated_first_name,\n    a.last_name as associated_last_name\nfrom book b\ninner join book_author_mapping m\n    on b.id = m.book_id \ninner join author a\n    on m.author_id = a.id\nwhere b.id = 1;\n")),(0,l.kt)("p",{parentName:"li"},"Query result may have duplicate aggregate root objects:"),(0,l.kt)("table",{parentName:"li"},(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"root_id"),(0,l.kt)("th",{parentName:"tr",align:null},"root_name"),(0,l.kt)("th",{parentName:"tr",align:null},"associated_id"),(0,l.kt)("th",{parentName:"tr",align:null},"associated_first_name"),(0,l.kt)("th",{parentName:"tr",align:null},"associated_last_name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Learning GraphQL"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Eve"),(0,l.kt)("td",{parentName:"tr",align:null},"Procello")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Learning GaphhQL"),(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"Alex"),(0,l.kt)("td",{parentName:"tr",align:null},"Banks")))))),(0,l.kt)("h3",{id:"harms-of-duplicate-results"},"Harms of Duplicate Results"),(0,l.kt)("p",null,"Table joins based on collection associations lead to duplicate data, which causes the following problems:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Bugs if the developer forgets deduplication.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Even if the developer does not forget deduplication, using ",(0,l.kt)("inlineCode",{parentName:"p"},"java.util.LinkedHashSet")," for deduplication post factum is not ideal."),(0,l.kt)("p",{parentName:"li"},"Because the fact that the original database result contains duplicates cannot be altered, and extra network transfer and JVM data processing costs are incurred.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Most importantly, unfriendly to pagination queries"),"."),(0,l.kt)("p",{parentName:"li"},"Paginating table join results at the SQL level is often not what people want. More often, people want pagination applied on aggregate root objects."),(0,l.kt)("p",{parentName:"li"},"Take Hibernate for example. In this case, Hibernate has to abandon SQL-level pagination and use memory-level pagination instead. This performs very poorly that Hibernate logs a warning to alert developers. If you have experience with Hibernate, the log below would give you a headache:"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"https://tech.asimio.net/2021/05/19/Fixing-Hibernate-HHH000104-firstResult-maxResults-warning-using-Spring-Data-JPA.html"},"firstResult/maxResults specified with collection fetch; applying in memory")),(0,l.kt)("admonition",{parentName:"li",type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"Note that Jimmer's other feature ",(0,l.kt)("a",{parentName:"p",href:"../object-fetcher"},"Object Fetcher")," does not use table join to fetch collection associations, so it does not have this problem. Feel free to use it.")))),(0,l.kt)("p",null,"In summary, using collection joins in top-level queries has obvious drawbacks, but it remains valuable to use collection joins in subqueries."),(0,l.kt)("p",null,"Therefore, Jimmer SQL DSL has the following characteristics:"),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("ol",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ol"},"Table joins based on collection associations are ",(0,l.kt)("strong",{parentName:"li"},"prohibited")," in ",(0,l.kt)("strong",{parentName:"li"},"top-level")," queries."),(0,l.kt)("li",{parentName:"ol"},"Table joins based on collection associations remain allowed in subqueries, update statements and delete statements. "))),(0,l.kt)("h2",{id:"implicit-subqueries"},"Implicit Subqueries"),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"For collection associations, JOIN is actually not recommended. ",(0,l.kt)("a",{parentName:"p",href:"../implicit-subquery"},"Implicit subqueries")," are more recommended. "),(0,l.kt)("p",{parentName:"admonition"},"If you still want to JOIN collection association properties, please continue reading below.")),(0,l.kt)("h2",{id:"table-and-tableex"},"Table and TableEx"),(0,l.kt)("p",null,"There are two kinds of table objects in Jimmer SQL DSL, ",(0,l.kt)("inlineCode",{parentName:"p"},"Table<E>")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"TableEx<E>"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Table"),(0,l.kt)("p",{parentName:"li"},"Features: Can only join via reference associations, cannot join via collection associations."),(0,l.kt)("p",{parentName:"li"},"Java type: org.babyfish.jimmer.sql.ast.table.Table","<","E",">"),(0,l.kt)("p",{parentName:"li"},"Kotlin type: org.babyfish.jimmer.sql.kt.ast.table.KTable","<","E",">"))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"TableEx"),(0,l.kt)("p",{parentName:"li"},"Features: Can join via any associations."),(0,l.kt)("p",{parentName:"li"},"Java type: org.babyfish.jimmer.sql.ast.table.TableEx","<","E",">"),(0,l.kt)("p",{parentName:"li"},"Kotlin type: org.babyfish.jimmer.sql.kt.ast.table.KTableEx","<","E",">"))),(0,l.kt)("h3",{id:"generated-code"},"Generated Code"),(0,l.kt)("p",null,"To implement strongly typed SQL DSL, Jimmer uses Annotation Processor (Java) or KSP (Kotlin) to generate SQL DSL related source code based on user-defined entity interfaces."),(0,l.kt)("p",null,"Take the Book entity interface at the beginning of this article as an example. The following two types would be generated automatically:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Generated Java Code"',title:'"Generated',Java:!0,'Code"':!0},'/*\n * BookTable.java \n */\npackage org.babyfish.jimmer.sql.example.model;\n\nimport java.lang.Integer;\nimport java.math.BigDecimal;\nimport javax.persistence.criteria.JoinType;\nimport org.babyfish.jimmer.sql.ast.Expression;\nimport org.babyfish.jimmer.sql.ast.PropExpression;\nimport org.babyfish.jimmer.sql.ast.table.Table;\nimport org.babyfish.jimmer.sql.ast.table.spi.AbstractTableWrapper;\n\npublic class BookTable extends AbstractTableWrapper<Book> {\n    public BookTable(Table<Book> table) {\n        super(table);\n    }\n\n    public Expression<Long> id() {\n        return get("id");\n    }\n\n    public PropExpression.Str name() {\n        return get("name");\n    }\n\n    public PropExpression.Num<Integer> edition() {\n        return get("edition");\n    }\n\n    public PropExpression.Num<BigDecimal> price() {\n        return get("price");\n    }\n\n    public BookStoreTable store() {\n        return join("store");\n    }\n\n    public BookStoreTable store(JoinType joinType) {\n        return join("store", joinType);\n    }\n}\n\n/*\n * BookTableEx.java\n */ \npackage org.babyfish.jimmer.sql.example.model;\n\nimport javax.persistence.criteria.JoinType;\nimport org.babyfish.jimmer.sql.ast.table.TableEx;\n\npublic class BookTableEx extends BookTable implements TableEx<Book> {\n    public BookTableEx(TableEx<Book> table) {\n        super(table);\n    }\n\n    public AuthorTableEx authors() {\n        return join("authors");\n    }\n\n    public AuthorTableEx authors(JoinType joinType) {\n        return join("authors", joinType);\n    }\n}\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Generated Kotlin Code"',title:'"Generated',Kotlin:!0,'Code"':!0},'package org.babyfish.jimmer.example.kt.sql.model\n\nimport java.math.BigDecimal\nimport org.babyfish.jimmer.sql.ast.Selection\nimport org.babyfish.jimmer.sql.kt.ast.expression.KNonNullPropExpression\nimport org.babyfish.jimmer.sql.kt.ast.expression.KNullablePropExpression\nimport org.babyfish.jimmer.sql.kt.ast.table.KNonNullTable\nimport org.babyfish.jimmer.sql.kt.ast.table.KNonNullTableEx\nimport org.babyfish.jimmer.sql.kt.ast.table.KNullableTable\nimport org.babyfish.jimmer.sql.kt.ast.table.KNullableTableEx\nimport org.babyfish.jimmer.sql.kt.ast.table.KTable\nimport org.babyfish.jimmer.sql.kt.ast.table.KTableEx\n\n/*\n * Extension for Table<Book>  \n */\npublic val KTable<Book>.id: KNullablePropExpression<Long>\n    get() = get("id")\n\npublic val KNonNullTable<Book>.id: KNonNullPropExpression<Long>\n    get() = get("id")\n\npublic val KTable<Book>.name: KNullablePropExpression<String>\n    get() = get("name")\n\npublic val KNonNullTable<Book>.name: KNonNullPropExpression<String>\n    get() = get("name")\n\npublic val KTable<Book>.edition: KNullablePropExpression<Int>\n    get() = get("edition")\n\npublic val KNonNullTable<Book>.edition: KNonNullPropExpression<Int>\n    get() = get("edition")\n\npublic val KTable<Book>.price: KNullablePropExpression<BigDecimal>\n    get() = get("price")\n\npublic val KNonNullTable<Book>.price: KNonNullPropExpression<BigDecimal>\n    get() = get("price")\n\npublic val KNullableTable<Book>.store: KNullableTable<BookStore>\n    get() = join("store")\n\npublic val KNonNullTable<Book>.store: KNonNullTable<BookStore>\n    get() = join("store")\n\npublic val KTable<Book>.`store?`: KNullableTable<BookStore>\n    get() = outerJoin("store")\n\n/*\n * Extension for TableEx<Book>\n */\n\npublic val KNullableTableEx<Book>.authors: KNullableTableEx<Author>\n    get() = join("authors")\n\npublic val KNonNullTableEx<Book>.authors: KNonNullTableEx<Author>\n    get() = join("authors")\n\npublic val KTableEx<Book>.`authors?`: KNullableTableEx<Author>\n    get() = outerJoin("authors")\n')))),(0,l.kt)("p",null,"Observing the two auto-generated types, we can see:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"BookTableEx")," inherits ",(0,l.kt)("inlineCode",{parentName:"li"},"BookTable"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"BookTable")," does not support collection associations, but supports regular fields and reference associations (which is ",(0,l.kt)("inlineCode",{parentName:"li"},"store")," in this example).  "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"BookTableEx")," adds support for collection associations (which is ",(0,l.kt)("inlineCode",{parentName:"li"},"authors")," in this example).")),(0,l.kt)("p",null,"Therefore, jimmer-sql API follows this pattern:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Top-level queries can only be created based on ",(0,l.kt)("inlineCode",{parentName:"li"},"Table"),".  "),(0,l.kt)("li",{parentName:"ul"},"Subqueries, update statements and delete statements can be created based on either ",(0,l.kt)("inlineCode",{parentName:"li"},"Table")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"TableEx"),".")),(0,l.kt)("p",null,"Next, we demonstrate the contrast between top-level queries and subqueries with examples."),(0,l.kt)("h3",{id:"top-level-queries-must-be-based-on-table"},"Top-Level Queries Must Be Based on Table"),(0,l.kt)("p",null,"So your code looks like:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable table = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(table)\n    .where(\n        table\n            // highlight-next-line\n            .name() // Can access regular field name  \n            .eq("Book Name")\n    )\n    .where(\n        table\n            // highlight-next-line \n            .store() // Can also join reference association store\n            .name()\n            .eq("Store Name")\n    )\n    /*\n     * However, cannot use "table.authors()" because `authors()`\n     * is defined in `BookTableEx` instead of `BookTable`.\n     *  \n     * That is, joining collection associations is prohibited  \n     * at compile time in top-level queries.\n     */ \n    .select(table)\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                // highlight-next-line\n                .name // Can access regular field name\n                eq "Book Name" \n        )\n        where(\n            table\n                // highlight-next-line\n                .store // Can also join reference association `store`\n                .name\n                eq "Store Name"\n        )\n        /*\n         * However, cannot use "table.authors" because the extension property `authors`\n         * is defined on `TableEx<Book>` instead of `Table<Book>`.\n         *  \n         * That is, joining collection associations is prohibited \n         * at compile time in top-level queries.\n         */\n        select(table)\n    }\n    .execute()\n')))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Java: ",(0,l.kt)("inlineCode",{parentName:"p"},"createQuery")," takes parameter specified by user, can only be ",(0,l.kt)("inlineCode",{parentName:"p"},"Table")," type. ",(0,l.kt)("inlineCode",{parentName:"p"},"TableEx")," would error.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Kotlin: ",(0,l.kt)("inlineCode",{parentName:"p"},"createQuery")," creates table object automatically. The automatic variable ",(0,l.kt)("inlineCode",{parentName:"p"},"table")," in lambda is inferred to ",(0,l.kt)("inlineCode",{parentName:"p"},"Table")," instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"TableEx"),".")))),(0,l.kt)("p",null,"The final generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\ninner join BOOK_STORE as tb_2_ on tb_1_.STORE_ID = tb_2_.ID\nwhere\n    tb_1_.NAME = ?\nand \n    tb_2_.NAME = ? \n")),(0,l.kt)("h3",{id:"tableex-allowed-for-subqueries"},"TableEx Allowed for Subqueries"),(0,l.kt)("p",null,"Unlike top-level queries, subqueries, update statements and delete statements allow TableEx. "),(0,l.kt)("p",null,"In the example below, ",(0,l.kt)("inlineCode",{parentName:"p"},"Author.books")," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors")," discussed above, which is also a many-to-many association."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable table = Tables.BOOK_TABLE;\n\n// `author` used in subquery, use TableEx\nAuthorTableEx author = TableExes.AUTHOR_TABLE_EX;\n\nList<Book> books = sqlClient\n    .createQuery(table)\n    .where(sqlClient\n        // highlight-next-line\n        .createSubQuery(author)\n        .where(\n            author\n                // `author` is TableEx, \n                // so collection association `books` is allowed\n                // highlight-next-line\n                .books()\n                .eq(table),\n\n            author.firstName().eq("Alex")\n        )\n        .exists()\n    )\n    .select(table)\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n\n        // In parent query `table` is Table<Book>\n        \n        where(\n            exists(\n                // highlight-next-line\n                wildSubQuery(Author::class) {\n\n                    // Subquery's `table` overrides parent's `table`,\n                    // and the Subquery's `table` is `TableEx<Author>`\n                    \n                    where(\n                        table\n                            // Subquery's `table` is TableEx,\n                            // so collection association `books` is allowed\n                            // highlight-next-line\n                            .books eq\n                            parentTable,\n\n                        table.firstName.eq(\"Alex\")\n                    )\n                }\n            )\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Java: ",(0,l.kt)("inlineCode",{parentName:"p"},"createSubQuery")," takes parameter specified by user, not enforced but suggested to be ",(0,l.kt)("inlineCode",{parentName:"p"},"TableEx")," type.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Kotlin: ",(0,l.kt)("inlineCode",{parentName:"p"},"wildSubQuery")," ",(0,l.kt)("em",{parentName:"p"},"(or ",(0,l.kt)("inlineCode",{parentName:"em"},"subQuery"),")")," creates table object automatically. The automatic variable ",(0,l.kt)("inlineCode",{parentName:"p"},"table")," in lambda is inferred to ",(0,l.kt)("inlineCode",{parentName:"p"},"TableEx")," instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"Table"),".  ")))),(0,l.kt)("p",null,"The final generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere exists(\n    select 1\n    from AUTHOR as tb_2_\n    // highlight-start\n    inner join BOOK_AUTHOR_MAPPING as tb_3_\n        on tb_2_.ID = tb_3_.AUTHOR_ID\n    // highlight-end\n    where\n        tb_3_.BOOK_ID = tb_1_.ID\n    and\n        tb_2_.FIRST_NAME = ?\n)  \n")),(0,l.kt)("h2",{id:"astableex"},"asTableEx"),(0,l.kt)("p",null,"Prohibiting collection associations in top-level queries is reasonable in most cases, but not all cases."),(0,l.kt)("p",null,"For example, the user does not query entire objects, but individual fields, and uses the SQL keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"distinct")," to offset the side effects of joining collection associations. This scenario is perfectly reasonable."),(0,l.kt)("p",null,"Therefore, prohibiting collection associations in top-level queries is a soft constraint rather than a hard constraint. It can be easily overridden."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<Long> bookIds = sqlClient\n    .createQuery(book)\n    .where(\n        book\n            .asTableEx() \u2776\n            .authors()\n            .firstName()\n            .ilike("A%")\n    )\n    .select(book.id()) \n    .distinct() \u2777\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                .asTableEx() \u2776\n                .authors\n                .firstName ilike "A%"\n        )\n        select(table.id)\n    }\n    .distinct() \u2777\n    .execute()\n')))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u2776 The developer informs Jimmer that they know what they are doing, asking Jimmer to allow joining collection associations.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u2777 The developer takes responsibility for their own actions. If there are additional operations here, it should be ",(0,l.kt)("inlineCode",{parentName:"p"},"distinct")," rather than pagination related.")))),(0,l.kt)("p",null,"The final generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    distinct tb_1_.ID\nfrom BOOK as tb_1_\n/* highlight-start */  \ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.BOOK_ID\ninner join AUTHOR as tb_3_\n    on tb_2_.AUTHOR_ID = tb_3_.ID\n/* highlight-end */\nwhere lower(tb_3_.FIRST_NAME) like ?\n")))}d.isMDXComponent=!0}}]);